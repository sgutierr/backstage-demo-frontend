/// <reference types="react" />
import { JsonObject, JsonValue } from '@backstage/types';
import * as React from 'react';
import React__default, { PropsWithChildren, ReactNode } from 'react';
import { ApiHolder, Extension, IconComponent } from '@backstage/core-plugin-api';
import * as _rjsf_utils from '@rjsf/utils';
import { FieldProps, UiSchema, UIOptionsType, FieldValidation } from '@rjsf/utils';
import { CustomFieldExtensionSchema, FieldExtensionComponent, TemplateParameterSchema, LayoutOptions, ScaffolderTaskOutput, ScaffolderStep } from '@backstage/plugin-scaffolder-react';
import * as _rjsf_core_v5 from '@rjsf/core-v5';
import { FormProps as FormProps$1 } from '@rjsf/core-v5';
import { TemplateEntityV1beta3, TaskStep } from '@backstage/plugin-scaffolder-common';

/**
 * Type for Field Extension Props for RJSF v5
 *
 * @alpha
 */
interface NextFieldExtensionComponentProps<TFieldReturnValue, TUiOptions = {}> extends PropsWithChildren<FieldProps<TFieldReturnValue>> {
    uiSchema?: NextFieldExtensionUiSchema<TFieldReturnValue, TUiOptions>;
}
/**
 * Type for Field Extension UiSchema
 *
 * @alpha
 */
interface NextFieldExtensionUiSchema<TFieldReturnValue, TUiOptions> extends UiSchema<TFieldReturnValue> {
    'ui:options'?: TUiOptions & UIOptionsType;
}
/**
 * Field validation type for Custom Field Extensions.
 *
 * @alpha
 */
type NextCustomFieldValidator<TFieldReturnValue, TUiOptions = unknown> = (data: TFieldReturnValue, field: FieldValidation, context: {
    apiHolder: ApiHolder;
    formData: JsonObject;
    schema: JsonObject;
    uiSchema?: NextFieldExtensionUiSchema<TFieldReturnValue, TUiOptions>;
}) => void | Promise<void>;
/**
 * Type for the Custom Field Extension with the
 * name and components and validation function.
 *
 * @alpha
 */
type NextFieldExtensionOptions<TFieldReturnValue = unknown, TUiOptions = unknown> = {
    name: string;
    component: (props: NextFieldExtensionComponentProps<TFieldReturnValue, TUiOptions>) => JSX.Element | null;
    validation?: NextCustomFieldValidator<TFieldReturnValue, TUiOptions>;
    schema?: CustomFieldExtensionSchema;
};

/**
 * Method for creating field extensions that can be used in the scaffolder
 * frontend form.
 * @alpha
 */
declare function createNextScaffolderFieldExtension<TReturnValue = unknown, TInputProps extends UIOptionsType = {}>(options: NextFieldExtensionOptions<TReturnValue, TInputProps>): Extension<FieldExtensionComponent<TReturnValue, TInputProps>>;

/**
 * This is the parsed template schema that is returned from the {@link useTemplateSchema} hook.
 * @alpha
 */
interface ParsedTemplateSchema {
    uiSchema: UiSchema;
    mergedSchema: JsonObject;
    schema: JsonObject;
    title: string;
    description?: string;
}
/**
 * This hook will parse the template schema and return the steps with the
 * parsed schema and uiSchema. Filtering out any steps or properties that
 * are not enabled with feature flags.
 * @alpha
 */
declare const useTemplateSchema: (manifest: TemplateParameterSchema) => {
    steps: ParsedTemplateSchema[];
};

/**
 * The props for the {@link ReviewState} component.
 * @alpha
 */
type ReviewStateProps = {
    schemas: ParsedTemplateSchema[];
    formState: JsonObject;
};
/**
 * The component used by the {@link Stepper} to render the review step.
 * @alpha
 */
declare const ReviewState: (props: ReviewStateProps) => JSX.Element;

/**
 * Any `@rjsf/core` form properties that are publicly exposed to the `NextScaffolderpage`
 *
 * @alpha
 */
type FormProps = Pick<FormProps$1, 'transformErrors' | 'noHtml5Validate'>;

/**
 * The Props for {@link Stepper} component
 * @alpha
 */
type StepperProps = {
    manifest: TemplateParameterSchema;
    extensions: NextFieldExtensionOptions<any, any>[];
    templateName?: string;
    FormProps?: FormProps;
    initialState?: Record<string, JsonValue>;
    onCreate: (values: Record<string, JsonValue>) => Promise<void>;
    components?: {
        ReviewStateComponent?: (props: ReviewStateProps) => JSX.Element;
        createButtonText?: ReactNode;
        reviewButtonText?: ReactNode;
    };
    layouts?: LayoutOptions[];
};
/**
 * The `Stepper` component is the Wizard that is rendered when a user selects a template
 * @alpha
 */
declare const Stepper: (stepperProps: StepperProps) => JSX.Element;

/**
 * The Props for the {@link TemplateCard} component
 * @alpha
 */
interface TemplateCardProps {
    template: TemplateEntityV1beta3;
    additionalLinks?: {
        icon: IconComponent;
        text: string;
        url: string;
    }[];
    onSelected?: (template: TemplateEntityV1beta3) => void;
}
/**
 * The `TemplateCard` component that is rendered in a list for each template
 * @alpha
 */
declare const TemplateCard: (props: TemplateCardProps) => JSX.Element;

/**
 * The props for the {@link TemplateGroup} component.
 * @alpha
 */
interface TemplateGroupProps {
    templates: {
        template: TemplateEntityV1beta3;
        additionalLinks?: {
            icon: IconComponent;
            text: string;
            url: string;
        }[];
    }[];
    onSelected: (template: TemplateEntityV1beta3) => void;
    title: React__default.ReactNode;
    components?: {
        CardComponent?: React__default.ComponentType<TemplateCardProps>;
    };
}
/**
 * The `TemplateGroup` component is used to display a group of templates with a title.
 * @alpha
 */
declare const TemplateGroup: (props: TemplateGroupProps) => JSX.Element;

/**
 * @alpha
 */
type TemplateGroupFilter = {
    title?: React__default.ReactNode;
    filter: (entity: TemplateEntityV1beta3) => boolean;
};
/**
 * @alpha
 */
interface TemplateGroupsProps {
    groups: TemplateGroupFilter[];
    templateFilter?: (entity: TemplateEntityV1beta3) => boolean;
    TemplateCardComponent?: React__default.ComponentType<{
        template: TemplateEntityV1beta3;
    }>;
    onTemplateSelected?: (template: TemplateEntityV1beta3) => void;
    additionalLinksForEntity?: (template: TemplateEntityV1beta3) => {
        icon: IconComponent;
        text: string;
        url: string;
    }[];
}
/**
 * @alpha
 */
declare const TemplateGroups: (props: TemplateGroupsProps) => JSX.Element | null;

/**
 * @alpha
 */
type WorkflowProps = {
    title?: string;
    description?: string;
    namespace: string;
    templateName: string;
    onError(error: Error | undefined): JSX.Element | null;
} & Pick<StepperProps, 'extensions' | 'FormProps' | 'components' | 'onCreate' | 'initialState' | 'layouts'>;
/**
 * @alpha
 */
declare const Workflow: (workflowProps: WorkflowProps) => JSX.Element | null;
/**
 * @alpha
 */
declare const EmbeddableWorkflow: (props: WorkflowProps) => JSX.Element;

/**
 * The DefaultOutputs renderer for the scaffolder task output
 *
 * @alpha
 */
declare const DefaultTemplateOutputs: (props: {
    output?: ScaffolderTaskOutput;
}) => JSX.Element | null;

/** @alpha */
declare const Form: React.ComponentType<_rjsf_core_v5.FormProps<any, _rjsf_utils.RJSFSchema, any>>;

/**
 * Props for the TaskSteps component
 *
 * @alpha
 */
interface TaskStepsProps {
    steps: (TaskStep & ScaffolderStep)[];
    activeStep?: number;
    isComplete?: boolean;
    isError?: boolean;
}
/**
 * The visual stepper of the task event stream
 *
 * @alpha
 */
declare const TaskSteps: (props: TaskStepsProps) => JSX.Element;

/**
 * The text of the event stream
 *
 * @alpha
 */
declare const TaskLogStream: (props: {
    logs: {
        [k: string]: string[];
    };
}) => JSX.Element;

/**
 * The Category Picker that is rendered on the left side for picking
 * categories and filtering the template list.
 * @alpha
 */
declare const TemplateCategoryPicker: () => JSX.Element | null;

/**
 * @alpha
 */
type ScaffolderPageContextMenuProps = {
    onEditorClicked?: () => void;
    onActionsClicked?: () => void;
    onTasksClicked?: () => void;
};
/**
 * @alpha
 */
declare function ScaffolderPageContextMenu(props: ScaffolderPageContextMenuProps): JSX.Element | null;

/**
 * Takes a step from a Backstage Template Manifest and converts it to a JSON Schema and UI Schema for rjsf
 * @alpha
 */
declare const extractSchemaFromStep: (inputStep: JsonObject) => {
    uiSchema: UiSchema;
    schema: JsonObject;
};
/**
 * Creates a field validation object for use in react jsonschema form
 * @alpha
 */
declare const createFieldValidation: () => FieldValidation;

/**
 * This hook is used to get the formData from the query string.
 * @alpha
 */
declare const useFormDataFromQuery: (initialState?: Record<string, JsonValue>) => [Record<string, any>, React.Dispatch<React.SetStateAction<Record<string, any>>>];

/**
 * @alpha
 */
declare const useTemplateParameterSchema: (templateRef: string) => {
    manifest: TemplateParameterSchema;
    loading: boolean;
    error: Error | undefined;
};

export { DefaultTemplateOutputs, EmbeddableWorkflow, Form, FormProps, NextCustomFieldValidator, NextFieldExtensionComponentProps, NextFieldExtensionOptions, NextFieldExtensionUiSchema, ParsedTemplateSchema, ReviewState, ReviewStateProps, ScaffolderPageContextMenu, ScaffolderPageContextMenuProps, Stepper, StepperProps, TaskLogStream, TaskSteps, TaskStepsProps, TemplateCard, TemplateCardProps, TemplateCategoryPicker, TemplateGroup, TemplateGroupFilter, TemplateGroupProps, TemplateGroups, TemplateGroupsProps, Workflow, WorkflowProps, createFieldValidation, createNextScaffolderFieldExtension, extractSchemaFromStep, useFormDataFromQuery, useTemplateParameterSchema, useTemplateSchema };
