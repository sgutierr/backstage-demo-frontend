import { parseEntityRef, stringifyLocationRef, stringifyEntityRef } from '@backstage/catalog-model';
import { ResponseError } from '@backstage/errors';
import crossFetch from 'cross-fetch';

const CATALOG_FILTER_EXISTS = Symbol.for(
  // Random UUID to ensure no collisions
  "CATALOG_FILTER_EXISTS_0e15b590c0b343a2bae3e787e84c2111"
);

function isQueryEntitiesInitialRequest(request) {
  return !request.cursor;
}

class CatalogClient {
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = options.fetchApi || { fetch: crossFetch };
  }
  /**
   * {@inheritdoc CatalogApi.getEntityAncestors}
   */
  async getEntityAncestors(request, options) {
    const { kind, namespace, name } = parseEntityRef(request.entityRef);
    return await this.requestRequired(
      "GET",
      `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(
        namespace
      )}/${encodeURIComponent(name)}/ancestry`,
      options
    );
  }
  /**
   * {@inheritdoc CatalogApi.getLocationById}
   */
  async getLocationById(id, options) {
    return await this.requestOptional(
      "GET",
      `/locations/${encodeURIComponent(id)}`,
      options
    );
  }
  /**
   * {@inheritdoc CatalogApi.getEntities}
   */
  async getEntities(request, options) {
    const {
      filter = [],
      fields = [],
      order,
      offset,
      limit,
      after
    } = request != null ? request : {};
    const params = this.getParams(filter);
    if (fields.length) {
      params.push(`fields=${fields.map(encodeURIComponent).join(",")}`);
    }
    if (order) {
      for (const directive of [order].flat()) {
        if (directive) {
          params.push(
            `order=${encodeURIComponent(directive.order)}:${encodeURIComponent(
              directive.field
            )}`
          );
        }
      }
    }
    if (offset !== void 0) {
      params.push(`offset=${offset}`);
    }
    if (limit !== void 0) {
      params.push(`limit=${limit}`);
    }
    if (after !== void 0) {
      params.push(`after=${encodeURIComponent(after)}`);
    }
    const query = params.length ? `?${params.join("&")}` : "";
    const entities = await this.requestRequired(
      "GET",
      `/entities${query}`,
      options
    );
    const refCompare = (a, b) => {
      var _a, _b;
      if (((_a = a.metadata) == null ? void 0 : _a.name) === void 0 || a.kind === void 0 || ((_b = b.metadata) == null ? void 0 : _b.name) === void 0 || b.kind === void 0) {
        return 0;
      }
      const aRef = stringifyEntityRef(a);
      const bRef = stringifyEntityRef(b);
      if (aRef < bRef) {
        return -1;
      }
      if (aRef > bRef) {
        return 1;
      }
      return 0;
    };
    return { items: entities.sort(refCompare) };
  }
  /**
   * {@inheritdoc CatalogApi.getEntitiesByRefs}
   */
  async getEntitiesByRefs(request, options) {
    var _a;
    const body = { entityRefs: request.entityRefs };
    if ((_a = request.fields) == null ? void 0 : _a.length) {
      body.fields = request.fields;
    }
    const baseUrl = await this.discoveryApi.getBaseUrl("catalog");
    const url = `${baseUrl}/entities/by-refs`;
    const response = await this.fetchApi.fetch(url, {
      headers: {
        "Content-Type": "application/json",
        ...(options == null ? void 0 : options.token) && { Authorization: `Bearer ${options == null ? void 0 : options.token}` }
      },
      method: "POST",
      body: JSON.stringify(body)
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    const { items } = await response.json();
    return { items: items.map((i) => i != null ? i : void 0) };
  }
  /**
   * {@inheritdoc CatalogApi.queryEntities}
   */
  async queryEntities(request = {}, options) {
    var _a, _b;
    const params = [];
    if (isQueryEntitiesInitialRequest(request)) {
      const {
        fields = [],
        filter,
        limit,
        orderFields,
        fullTextFilter
      } = request;
      params.push(...this.getParams(filter));
      if (limit !== void 0) {
        params.push(`limit=${limit}`);
      }
      if (orderFields !== void 0) {
        (Array.isArray(orderFields) ? orderFields : [orderFields]).forEach(
          ({ field, order }) => params.push(`orderField=${field},${order}`)
        );
      }
      if (fields.length) {
        params.push(`fields=${fields.map(encodeURIComponent).join(",")}`);
      }
      const normalizedFullTextFilterTerm = (_a = fullTextFilter == null ? void 0 : fullTextFilter.term) == null ? void 0 : _a.trim();
      if (normalizedFullTextFilterTerm) {
        params.push(`fullTextFilterTerm=${normalizedFullTextFilterTerm}`);
      }
      if ((_b = fullTextFilter == null ? void 0 : fullTextFilter.fields) == null ? void 0 : _b.length) {
        params.push(`fullTextFilterFields=${fullTextFilter.fields.join(",")}`);
      }
    } else {
      const { fields = [], limit, cursor } = request;
      params.push(`cursor=${cursor}`);
      if (limit !== void 0) {
        params.push(`limit=${limit}`);
      }
      if (fields.length) {
        params.push(`fields=${fields.map(encodeURIComponent).join(",")}`);
      }
    }
    const query = params.length ? `?${params.join("&")}` : "";
    return this.requestRequired(
      "GET",
      `/entities/by-query${query}`,
      options
    );
  }
  /**
   * {@inheritdoc CatalogApi.getEntityByRef}
   */
  async getEntityByRef(entityRef, options) {
    const { kind, namespace, name } = parseEntityRef(entityRef);
    return this.requestOptional(
      "GET",
      `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(
        namespace
      )}/${encodeURIComponent(name)}`,
      options
    );
  }
  // NOTE(freben): When we deprecate getEntityByName from the interface, we may
  // still want to leave this implementation in place for quite some time
  // longer, to minimize the risk for breakages. Suggested date for removal:
  // August 2022
  /**
   * @deprecated Use getEntityByRef instead
   */
  async getEntityByName(compoundName, options) {
    const { kind, namespace = "default", name } = compoundName;
    return this.requestOptional(
      "GET",
      `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(
        namespace
      )}/${encodeURIComponent(name)}`,
      options
    );
  }
  /**
   * {@inheritdoc CatalogApi.refreshEntity}
   */
  async refreshEntity(entityRef, options) {
    const response = await this.fetchApi.fetch(
      `${await this.discoveryApi.getBaseUrl("catalog")}/refresh`,
      {
        headers: {
          "Content-Type": "application/json",
          ...(options == null ? void 0 : options.token) && { Authorization: `Bearer ${options == null ? void 0 : options.token}` }
        },
        method: "POST",
        body: JSON.stringify({ entityRef })
      }
    );
    if (response.status !== 200) {
      throw new Error(await response.text());
    }
  }
  /**
   * {@inheritdoc CatalogApi.getEntityFacets}
   */
  async getEntityFacets(request, options) {
    const { filter = [], facets } = request;
    const params = this.getParams(filter);
    for (const facet of facets) {
      params.push(`facet=${encodeURIComponent(facet)}`);
    }
    const query = params.length ? `?${params.join("&")}` : "";
    return await this.requestOptional("GET", `/entity-facets${query}`, options);
  }
  /**
   * {@inheritdoc CatalogApi.addLocation}
   */
  async addLocation(request, options) {
    const { type = "url", target, dryRun } = request;
    const response = await this.fetchApi.fetch(
      `${await this.discoveryApi.getBaseUrl("catalog")}/locations${dryRun ? "?dryRun=true" : ""}`,
      {
        headers: {
          "Content-Type": "application/json",
          ...(options == null ? void 0 : options.token) && { Authorization: `Bearer ${options == null ? void 0 : options.token}` }
        },
        method: "POST",
        body: JSON.stringify({ type, target })
      }
    );
    if (response.status !== 201) {
      throw new Error(await response.text());
    }
    const { location, entities, exists } = await response.json();
    if (!location) {
      throw new Error(`Location wasn't added: ${target}`);
    }
    return {
      location,
      entities,
      exists
    };
  }
  /**
   * {@inheritdoc CatalogApi.getLocationByRef}
   */
  async getLocationByRef(locationRef, options) {
    const all = await this.requestRequired(
      "GET",
      "/locations",
      options
    );
    return all.map((r) => r.data).find((l) => locationRef === stringifyLocationRef(l));
  }
  /**
   * {@inheritdoc CatalogApi.removeLocationById}
   */
  async removeLocationById(id, options) {
    await this.requestIgnored(
      "DELETE",
      `/locations/${encodeURIComponent(id)}`,
      options
    );
  }
  /**
   * {@inheritdoc CatalogApi.removeEntityByUid}
   */
  async removeEntityByUid(uid, options) {
    await this.requestIgnored(
      "DELETE",
      `/entities/by-uid/${encodeURIComponent(uid)}`,
      options
    );
  }
  /**
   * {@inheritdoc CatalogApi.validateEntity}
   */
  async validateEntity(entity, locationRef, options) {
    const response = await this.fetchApi.fetch(
      `${await this.discoveryApi.getBaseUrl("catalog")}/validate-entity`,
      {
        headers: {
          "Content-Type": "application/json",
          ...(options == null ? void 0 : options.token) && { Authorization: `Bearer ${options == null ? void 0 : options.token}` }
        },
        method: "POST",
        body: JSON.stringify({ entity, location: locationRef })
      }
    );
    if (response.ok) {
      return {
        valid: true
      };
    }
    if (response.status !== 400) {
      throw await ResponseError.fromResponse(response);
    }
    const { errors = [] } = await response.json();
    return {
      valid: false,
      errors
    };
  }
  //
  // Private methods
  //
  async requestIgnored(method, path, options) {
    const url = `${await this.discoveryApi.getBaseUrl("catalog")}${path}`;
    const headers = (options == null ? void 0 : options.token) ? { Authorization: `Bearer ${options.token}` } : {};
    const response = await this.fetchApi.fetch(url, { method, headers });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
  }
  async requestRequired(method, path, options) {
    const url = `${await this.discoveryApi.getBaseUrl("catalog")}${path}`;
    const headers = (options == null ? void 0 : options.token) ? { Authorization: `Bearer ${options.token}` } : {};
    const response = await this.fetchApi.fetch(url, { method, headers });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return response.json();
  }
  async requestOptional(method, path, options) {
    const url = `${await this.discoveryApi.getBaseUrl("catalog")}${path}`;
    const headers = (options == null ? void 0 : options.token) ? { Authorization: `Bearer ${options.token}` } : {};
    const response = await this.fetchApi.fetch(url, { method, headers });
    if (!response.ok) {
      if (response.status === 404) {
        return void 0;
      }
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  getParams(filter = []) {
    const params = [];
    for (const filterItem of [filter].flat()) {
      const filterParts = [];
      for (const [key, value] of Object.entries(filterItem)) {
        for (const v of [value].flat()) {
          if (v === CATALOG_FILTER_EXISTS) {
            filterParts.push(encodeURIComponent(key));
          } else if (typeof v === "string") {
            filterParts.push(
              `${encodeURIComponent(key)}=${encodeURIComponent(v)}`
            );
          }
        }
      }
      if (filterParts.length) {
        params.push(`filter=${filterParts.join(",")}`);
      }
    }
    return params;
  }
}

const ENTITY_STATUS_CATALOG_PROCESSING_TYPE = "backstage.io/catalog-processing";

export { CATALOG_FILTER_EXISTS, CatalogClient, ENTITY_STATUS_CATALOG_PROCESSING_TYPE };
//# sourceMappingURL=index.esm.js.map
