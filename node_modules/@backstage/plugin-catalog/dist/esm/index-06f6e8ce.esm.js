import ObservableImpl from 'zen-observable';
import { stringifyEntityRef, RELATION_PART_OF, RELATION_OWNED_BY, getEntitySourceLocation, ANNOTATION_EDIT_URL, DEFAULT_NAMESPACE, ANNOTATION_LOCATION, ANNOTATION_VIEW_URL } from '@backstage/catalog-model';
import { isArray, isString, capitalize } from 'lodash';
import { Link, MarkdownContent, HeaderIconLinkRow, OverflowTooltip, WarningPanel, CodeSnippet, Table, Page, Header, Progress, RoutedTabs, Content, HeaderLabel, ResponseErrorPanel, InfoCard } from '@backstage/core-components';
import { createExternalRouteRef, createRouteRef, useElementFilter, useApi, alertApiRef, errorApiRef, useRouteRef, attachComponentData, useRouteRefParams, useApiHolder, createPlugin, createApiFactory, discoveryApiRef, fetchApiRef, storageApiRef, createRoutableExtension, createComponentExtension } from '@backstage/core-plugin-api';
import { scmIntegrationsApiRef, ScmIntegrationIcon } from '@backstage/integration-react';
import { getEntityRelations, EntityRefLinks, useEntity, catalogApiRef, getEntitySourceLocation as getEntitySourceLocation$1, useEntityList, EntityKindFilter, EntityRefLink, humanizeEntityRef, useStarredEntities, entityRouteRef, useAsyncEntity, UnregisterEntityDialog, InspectEntityDialog, FavoriteEntity, CatalogFilterLayout, starredEntitiesApiRef } from '@backstage/plugin-catalog-react';
import { makeStyles, Typography, Grid, Box, useMediaQuery, ImageList, ImageListItem, Chip, Card, CardHeader, IconButton, Divider, CardContent, createStyles, Select, InputBase, MenuItem, ListItemIcon, ListItemText, Tooltip, Popover, MenuList, Dialog, DialogTitle, DialogActions, Button } from '@material-ui/core';
import CachedIcon from '@material-ui/icons/Cached';
import DocsIcon from '@material-ui/icons/Description';
import EditIcon from '@material-ui/icons/Edit';
import React, { useCallback, useMemo, useState, useEffect } from 'react';
import LanguageIcon from '@material-ui/icons/Language';
import pluralize from 'pluralize';
import useAsync from 'react-use/lib/useAsync';
import { withStyles, makeStyles as makeStyles$1 } from '@material-ui/core/styles';
import OpenInNew from '@material-ui/icons/OpenInNew';
import Star from '@material-ui/icons/Star';
import StarBorder from '@material-ui/icons/StarBorder';
import { Alert } from '@material-ui/lab';
import { useLocation, useNavigate } from 'react-router-dom';
import BugReportIcon from '@material-ui/icons/BugReport';
import MoreVert from '@material-ui/icons/MoreVert';
import FileCopyTwoToneIcon from '@material-ui/icons/FileCopyTwoTone';
import { useEntityPermission } from '@backstage/plugin-catalog-react/alpha';
import { catalogEntityDeletePermission } from '@backstage/plugin-catalog-common/alpha';
import CancelIcon from '@material-ui/icons/Cancel';
import { assertError } from '@backstage/errors';
import { ENTITY_STATUS_CATALOG_PROCESSING_TYPE, CatalogClient } from '@backstage/catalog-client';
import { createSearchResultListItemExtension } from '@backstage/plugin-search-react';

async function performMigrationToTheNewBucket({
  storageApi
}) {
  var _a;
  const source = storageApi.forBucket("settings");
  const target = storageApi.forBucket("starredEntities");
  const oldStarredEntities = source.snapshot("starredEntities").value;
  if (!isArray(oldStarredEntities)) {
    return;
  }
  const targetEntities = new Set(
    (_a = target.snapshot("entityRefs").value) != null ? _a : []
  );
  oldStarredEntities.filter(isString).map((old) => old.split(":")).filter((split) => split.length === 4 && split[0] === "entity").map(
    ([_, kind, namespace, name]) => stringifyEntityRef({ kind, namespace, name })
  ).forEach((e) => targetEntities.add(e));
  await target.set("entityRefs", Array.from(targetEntities));
  await source.remove("starredEntities");
}

class DefaultStarredEntitiesApi {
  constructor(opts) {
    this.subscribers = /* @__PURE__ */ new Set();
    this.observable = new ObservableImpl((subscriber) => {
      subscriber.next(new Set(this.starredEntities));
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
    var _a;
    performMigrationToTheNewBucket(opts).then();
    this.settingsStore = opts.storageApi.forBucket("starredEntities");
    this.starredEntities = new Set(
      (_a = this.settingsStore.snapshot("entityRefs").value) != null ? _a : []
    );
    this.settingsStore.observe$("entityRefs").subscribe({
      next: (next) => {
        var _a2;
        this.starredEntities = new Set((_a2 = next.value) != null ? _a2 : []);
        this.notifyChanges();
      }
    });
  }
  async toggleStarred(entityRef) {
    if (this.starredEntities.has(entityRef)) {
      this.starredEntities.delete(entityRef);
    } else {
      this.starredEntities.add(entityRef);
    }
    await this.settingsStore.set(
      "entityRefs",
      Array.from(this.starredEntities)
    );
  }
  starredEntitie$() {
    return this.observable;
  }
  notifyChanges() {
    for (const subscription of this.subscribers) {
      subscription.next(new Set(this.starredEntities));
    }
  }
}

const createComponentRouteRef = createExternalRouteRef({
  id: "create-component",
  optional: true
});
const viewTechDocRouteRef = createExternalRouteRef({
  id: "view-techdoc",
  optional: true,
  params: ["namespace", "kind", "name"]
});
const rootRouteRef = createRouteRef({
  id: "catalog"
});

const useStyles$7 = makeStyles((theme) => ({
  value: {
    fontWeight: "bold",
    overflow: "hidden",
    lineHeight: "24px",
    wordBreak: "break-word"
  },
  label: {
    color: theme.palette.text.secondary,
    textTransform: "uppercase",
    fontSize: "10px",
    fontWeight: "bold",
    letterSpacing: 0.5,
    overflow: "hidden",
    whiteSpace: "nowrap"
  }
}));
function AboutField(props) {
  const { label, value, gridSizes, children } = props;
  const classes = useStyles$7();
  const childElements = useElementFilter(children, (c) => c.getElements());
  const content = childElements.length > 0 ? childElements : /* @__PURE__ */ React.createElement(Typography, { variant: "body2", className: classes.value }, value || `unknown`);
  return /* @__PURE__ */ React.createElement(Grid, { item: true, ...gridSizes }, /* @__PURE__ */ React.createElement(Typography, { variant: "h2", className: classes.label }, label), content);
}

const useStyles$6 = makeStyles({
  svgIcon: {
    display: "inline-block",
    "& svg": {
      display: "inline-block",
      fontSize: "inherit",
      verticalAlign: "baseline"
    }
  }
});
function IconLink(props) {
  const { href, text, Icon } = props;
  const classes = useStyles$6();
  return /* @__PURE__ */ React.createElement(Box, { display: "flex" }, /* @__PURE__ */ React.createElement(Box, { mr: 1, className: classes.svgIcon }, /* @__PURE__ */ React.createElement(Typography, { component: "div" }, Icon ? /* @__PURE__ */ React.createElement(Icon, null) : /* @__PURE__ */ React.createElement(LanguageIcon, null))), /* @__PURE__ */ React.createElement(Box, { flexGrow: "1" }, /* @__PURE__ */ React.createElement(Link, { to: href, target: "_blank", rel: "noopener" }, text || href)));
}

const colDefaults = {
  xs: 1,
  sm: 1,
  md: 1,
  lg: 2,
  xl: 3
};
function useDynamicColumns(cols) {
  var _a, _b;
  const matches = [
    useMediaQuery((theme) => theme.breakpoints.up("xl")) ? "xl" : null,
    useMediaQuery((theme) => theme.breakpoints.up("lg")) ? "lg" : null,
    useMediaQuery((theme) => theme.breakpoints.up("md")) ? "md" : null,
    useMediaQuery((theme) => theme.breakpoints.up("sm")) ? "sm" : null,
    useMediaQuery((theme) => theme.breakpoints.up("xs")) ? "xs" : null
  ];
  let numOfCols = 1;
  if (typeof cols === "number") {
    numOfCols = cols;
  } else {
    const breakpoint = (_a = matches.find((k) => k !== null)) != null ? _a : "xs";
    numOfCols = (_b = cols == null ? void 0 : cols[breakpoint]) != null ? _b : colDefaults[breakpoint];
  }
  return numOfCols;
}

function LinksGridList(props) {
  const { items, cols = void 0 } = props;
  const numOfCols = useDynamicColumns(cols);
  return /* @__PURE__ */ React.createElement(ImageList, { rowHeight: "auto", cols: numOfCols }, items.map(({ text, href, Icon }, i) => /* @__PURE__ */ React.createElement(ImageListItem, { key: i }, /* @__PURE__ */ React.createElement(IconLink, { href, text: text != null ? text : href, Icon }))));
}

const useStyles$5 = makeStyles({
  description: {
    wordBreak: "break-word"
  }
});
function getLocationTargetHref(target, type, entitySourceLocation) {
  if (type === "url" || target.includes("://")) {
    return target;
  }
  const srcLocationUrl = entitySourceLocation.type === "file" ? `file://${entitySourceLocation.target}` : entitySourceLocation.target;
  if (type === "file" || entitySourceLocation.type === "file") {
    return new URL(target, srcLocationUrl).href;
  }
  return srcLocationUrl;
}
function AboutContent(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { entity } = props;
  const classes = useStyles$5();
  const isSystem = entity.kind.toLocaleLowerCase("en-US") === "system";
  const isResource = entity.kind.toLocaleLowerCase("en-US") === "resource";
  const isComponent = entity.kind.toLocaleLowerCase("en-US") === "component";
  const isAPI = entity.kind.toLocaleLowerCase("en-US") === "api";
  const isTemplate = entity.kind.toLocaleLowerCase("en-US") === "template";
  const isLocation = entity.kind.toLocaleLowerCase("en-US") === "location";
  const isGroup = entity.kind.toLocaleLowerCase("en-US") === "group";
  const partOfSystemRelations = getEntityRelations(entity, RELATION_PART_OF, {
    kind: "system"
  });
  const partOfComponentRelations = getEntityRelations(
    entity,
    RELATION_PART_OF,
    {
      kind: "component"
    }
  );
  const partOfDomainRelations = getEntityRelations(entity, RELATION_PART_OF, {
    kind: "domain"
  });
  const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
  let entitySourceLocation;
  try {
    entitySourceLocation = getEntitySourceLocation(entity);
  } catch (e) {
    entitySourceLocation = void 0;
  }
  return /* @__PURE__ */ React.createElement(Grid, { container: true }, /* @__PURE__ */ React.createElement(AboutField, { label: "Description", gridSizes: { xs: 12 } }, /* @__PURE__ */ React.createElement(
    MarkdownContent,
    {
      className: classes.description,
      content: ((_a = entity == null ? void 0 : entity.metadata) == null ? void 0 : _a.description) || "No description"
    }
  )), /* @__PURE__ */ React.createElement(
    AboutField,
    {
      label: "Owner",
      value: "No Owner",
      gridSizes: { xs: 12, sm: 6, lg: 4 }
    },
    ownedByRelations.length > 0 && /* @__PURE__ */ React.createElement(EntityRefLinks, { entityRefs: ownedByRelations, defaultKind: "group" })
  ), (isSystem || partOfDomainRelations.length > 0) && /* @__PURE__ */ React.createElement(
    AboutField,
    {
      label: "Domain",
      value: "No Domain",
      gridSizes: { xs: 12, sm: 6, lg: 4 }
    },
    partOfDomainRelations.length > 0 && /* @__PURE__ */ React.createElement(
      EntityRefLinks,
      {
        entityRefs: partOfDomainRelations,
        defaultKind: "domain"
      }
    )
  ), (isAPI || isComponent || isResource || partOfSystemRelations.length > 0) && /* @__PURE__ */ React.createElement(
    AboutField,
    {
      label: "System",
      value: "No System",
      gridSizes: { xs: 12, sm: 6, lg: 4 }
    },
    partOfSystemRelations.length > 0 && /* @__PURE__ */ React.createElement(
      EntityRefLinks,
      {
        entityRefs: partOfSystemRelations,
        defaultKind: "system"
      }
    )
  ), isComponent && partOfComponentRelations.length > 0 && /* @__PURE__ */ React.createElement(
    AboutField,
    {
      label: "Parent Component",
      value: "No Parent Component",
      gridSizes: { xs: 12, sm: 6, lg: 4 }
    },
    /* @__PURE__ */ React.createElement(
      EntityRefLinks,
      {
        entityRefs: partOfComponentRelations,
        defaultKind: "component"
      }
    )
  ), (isAPI || isComponent || isResource || isTemplate || isGroup || isLocation || typeof ((_b = entity == null ? void 0 : entity.spec) == null ? void 0 : _b.type) === "string") && /* @__PURE__ */ React.createElement(
    AboutField,
    {
      label: "Type",
      value: (_c = entity == null ? void 0 : entity.spec) == null ? void 0 : _c.type,
      gridSizes: { xs: 12, sm: 6, lg: 4 }
    }
  ), (isAPI || isComponent || typeof ((_d = entity == null ? void 0 : entity.spec) == null ? void 0 : _d.lifecycle) === "string") && /* @__PURE__ */ React.createElement(
    AboutField,
    {
      label: "Lifecycle",
      value: (_e = entity == null ? void 0 : entity.spec) == null ? void 0 : _e.lifecycle,
      gridSizes: { xs: 12, sm: 6, lg: 4 }
    }
  ), /* @__PURE__ */ React.createElement(
    AboutField,
    {
      label: "Tags",
      value: "No Tags",
      gridSizes: { xs: 12, sm: 6, lg: 4 }
    },
    (((_f = entity == null ? void 0 : entity.metadata) == null ? void 0 : _f.tags) || []).map((t) => /* @__PURE__ */ React.createElement(Chip, { key: t, size: "small", label: t }))
  ), isLocation && (((_g = entity == null ? void 0 : entity.spec) == null ? void 0 : _g.targets) || ((_h = entity == null ? void 0 : entity.spec) == null ? void 0 : _h.target)) && /* @__PURE__ */ React.createElement(AboutField, { label: "Targets", gridSizes: { xs: 12 } }, /* @__PURE__ */ React.createElement(
    LinksGridList,
    {
      cols: 1,
      items: (entity.spec.targets || [entity.spec.target]).map((target) => target).map((target) => {
        var _a2;
        return {
          text: target,
          href: getLocationTargetHref(
            target,
            ((_a2 = entity == null ? void 0 : entity.spec) == null ? void 0 : _a2.type) || "unknown",
            entitySourceLocation
          )
        };
      })
    }
  )));
}

const useStyles$4 = makeStyles({
  gridItemCard: {
    display: "flex",
    flexDirection: "column",
    height: "calc(100% - 10px)",
    // for pages without content header
    marginBottom: "10px"
  },
  fullHeightCard: {
    display: "flex",
    flexDirection: "column",
    height: "100%"
  },
  gridItemCardContent: {
    flex: 1
  },
  fullHeightCardContent: {
    flex: 1
  }
});
function AboutCard(props) {
  var _a, _b, _c;
  const { variant } = props;
  const classes = useStyles$4();
  const { entity } = useEntity();
  const scmIntegrationsApi = useApi(scmIntegrationsApiRef);
  const catalogApi = useApi(catalogApiRef);
  const alertApi = useApi(alertApiRef);
  const errorApi = useApi(errorApiRef);
  const viewTechdocLink = useRouteRef(viewTechDocRouteRef);
  const entitySourceLocation = getEntitySourceLocation$1(
    entity,
    scmIntegrationsApi
  );
  const entityMetadataEditUrl = (_a = entity.metadata.annotations) == null ? void 0 : _a[ANNOTATION_EDIT_URL];
  const viewInSource = {
    label: "View Source",
    disabled: !entitySourceLocation,
    icon: /* @__PURE__ */ React.createElement(ScmIntegrationIcon, { type: entitySourceLocation == null ? void 0 : entitySourceLocation.integrationType }),
    href: entitySourceLocation == null ? void 0 : entitySourceLocation.locationTargetUrl
  };
  const viewInTechDocs = {
    label: "View TechDocs",
    disabled: !((_b = entity.metadata.annotations) == null ? void 0 : _b["backstage.io/techdocs-ref"]) || !viewTechdocLink,
    icon: /* @__PURE__ */ React.createElement(DocsIcon, null),
    href: viewTechdocLink && viewTechdocLink({
      namespace: entity.metadata.namespace || DEFAULT_NAMESPACE,
      kind: entity.kind,
      name: entity.metadata.name
    })
  };
  let cardClass = "";
  if (variant === "gridItem") {
    cardClass = classes.gridItemCard;
  } else if (variant === "fullHeight") {
    cardClass = classes.fullHeightCard;
  }
  let cardContentClass = "";
  if (variant === "gridItem") {
    cardContentClass = classes.gridItemCardContent;
  } else if (variant === "fullHeight") {
    cardContentClass = classes.fullHeightCardContent;
  }
  const entityLocation = (_c = entity.metadata.annotations) == null ? void 0 : _c[ANNOTATION_LOCATION];
  const allowRefresh = (entityLocation == null ? void 0 : entityLocation.startsWith("url:")) || (entityLocation == null ? void 0 : entityLocation.startsWith("file:"));
  const refreshEntity = useCallback(async () => {
    try {
      await catalogApi.refreshEntity(stringifyEntityRef(entity));
      alertApi.post({ message: "Refresh scheduled", severity: "info" });
    } catch (e) {
      errorApi.post(e);
    }
  }, [catalogApi, alertApi, errorApi, entity]);
  return /* @__PURE__ */ React.createElement(Card, { className: cardClass }, /* @__PURE__ */ React.createElement(
    CardHeader,
    {
      title: "About",
      action: /* @__PURE__ */ React.createElement(React.Fragment, null, allowRefresh && /* @__PURE__ */ React.createElement(
        IconButton,
        {
          "aria-label": "Refresh",
          title: "Schedule entity refresh",
          onClick: refreshEntity
        },
        /* @__PURE__ */ React.createElement(CachedIcon, null)
      ), /* @__PURE__ */ React.createElement(
        IconButton,
        {
          component: Link,
          "aria-label": "Edit",
          disabled: !entityMetadataEditUrl,
          title: "Edit Metadata",
          to: entityMetadataEditUrl != null ? entityMetadataEditUrl : "#"
        },
        /* @__PURE__ */ React.createElement(EditIcon, null)
      )),
      subheader: /* @__PURE__ */ React.createElement(HeaderIconLinkRow, { links: [viewInSource, viewInTechDocs] })
    }
  ), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(CardContent, { className: cardContentClass }, /* @__PURE__ */ React.createElement(AboutContent, { entity })));
}

function useAllKinds() {
  const catalogApi = useApi(catalogApiRef);
  const {
    error,
    loading,
    value: allKinds
  } = useAsync(async () => {
    const items = await catalogApi.getEntityFacets({ facets: ["kind"] }).then((response) => {
      var _a;
      return ((_a = response.facets.kind) == null ? void 0 : _a.map((f) => f.value).sort()) || [];
    });
    return items;
  }, [catalogApi]);
  return { loading, error, allKinds: allKinds != null ? allKinds : [] };
}
function filterKinds(allKinds, allowedKinds, forcedKinds) {
  let availableKinds = allKinds;
  if (allowedKinds) {
    availableKinds = availableKinds.filter(
      (k) => allowedKinds.some(
        (a) => a.toLocaleLowerCase("en-US") === k.toLocaleLowerCase("en-US")
      )
    );
  }
  if (forcedKinds && !allKinds.some(
    (a) => a.toLocaleLowerCase("en-US") === forcedKinds.toLocaleLowerCase("en-US")
  )) {
    availableKinds = availableKinds.concat([forcedKinds]);
  }
  const kindsMap = availableKinds.sort().reduce((acc, kind) => {
    acc[kind.toLocaleLowerCase("en-US")] = kind;
    return acc;
  }, {});
  return kindsMap;
}

const useStyles$3 = makeStyles(
  (theme) => createStyles({
    root: {
      ...theme.typography.h4
    }
  })
);
function CatalogKindHeader(props) {
  var _a, _b;
  const { initialFilter = "component", allowedKinds } = props;
  const classes = useStyles$3();
  const { allKinds } = useAllKinds();
  const {
    filters,
    updateFilters,
    queryParameters: { kind: kindParameter }
  } = useEntityList();
  const queryParamKind = useMemo(
    () => [kindParameter].flat()[0],
    [kindParameter]
  );
  const [selectedKind, setSelectedKind] = useState(
    (_b = queryParamKind != null ? queryParamKind : (_a = filters.kind) == null ? void 0 : _a.value) != null ? _b : initialFilter
  );
  useEffect(() => {
    if (queryParamKind) {
      setSelectedKind(queryParamKind);
    }
  }, [queryParamKind]);
  useEffect(() => {
    var _a2, _b2;
    if ((_a2 = filters.kind) == null ? void 0 : _a2.value) {
      setSelectedKind((_b2 = filters.kind) == null ? void 0 : _b2.value);
    }
  }, [filters.kind]);
  useEffect(() => {
    updateFilters({
      kind: selectedKind ? new EntityKindFilter(selectedKind) : void 0
    });
  }, [selectedKind, updateFilters]);
  const options = filterKinds(allKinds, allowedKinds, selectedKind);
  return /* @__PURE__ */ React.createElement(
    Select,
    {
      input: /* @__PURE__ */ React.createElement(InputBase, null),
      value: selectedKind.toLocaleLowerCase("en-US"),
      onChange: (e) => setSelectedKind(e.target.value),
      classes
    },
    Object.keys(options).map((kind) => /* @__PURE__ */ React.createElement(MenuItem, { value: kind, key: kind }, `${pluralize(options[kind])}`))
  );
}

const columnFactories = Object.freeze({
  createNameColumn(options) {
    function formatContent(entity) {
      var _a;
      return ((_a = entity.metadata) == null ? void 0 : _a.title) || humanizeEntityRef(entity, {
        defaultKind: options == null ? void 0 : options.defaultKind
      });
    }
    return {
      title: "Name",
      field: "resolved.name",
      highlight: true,
      customSort({ entity: entity1 }, { entity: entity2 }) {
        return formatContent(entity1).localeCompare(formatContent(entity2));
      },
      render: ({ entity }) => {
        var _a;
        return /* @__PURE__ */ React.createElement(
          EntityRefLink,
          {
            entityRef: entity,
            defaultKind: (options == null ? void 0 : options.defaultKind) || "Component",
            title: (_a = entity.metadata) == null ? void 0 : _a.title
          }
        );
      }
    };
  },
  createSystemColumn() {
    return {
      title: "System",
      field: "resolved.partOfSystemRelationTitle",
      render: ({ resolved }) => /* @__PURE__ */ React.createElement(
        EntityRefLinks,
        {
          entityRefs: resolved.partOfSystemRelations,
          defaultKind: "system"
        }
      )
    };
  },
  createOwnerColumn() {
    return {
      title: "Owner",
      field: "resolved.ownedByRelationsTitle",
      render: ({ resolved }) => /* @__PURE__ */ React.createElement(
        EntityRefLinks,
        {
          entityRefs: resolved.ownedByRelations,
          defaultKind: "group"
        }
      )
    };
  },
  createSpecTargetsColumn() {
    return {
      title: "Targets",
      field: "entity.spec.targets",
      render: ({ entity }) => {
        var _a, _b;
        return /* @__PURE__ */ React.createElement(React.Fragment, null, (((_a = entity == null ? void 0 : entity.spec) == null ? void 0 : _a.targets) || ((_b = entity == null ? void 0 : entity.spec) == null ? void 0 : _b.target)) && /* @__PURE__ */ React.createElement(
          OverflowTooltip,
          {
            text: (entity.spec.targets || [entity.spec.target]).join(", "),
            placement: "bottom-start"
          }
        ));
      }
    };
  },
  createSpecTypeColumn() {
    return {
      title: "Type",
      field: "entity.spec.type",
      hidden: true,
      width: "auto"
    };
  },
  createSpecLifecycleColumn() {
    return {
      title: "Lifecycle",
      field: "entity.spec.lifecycle"
    };
  },
  createMetadataDescriptionColumn() {
    return {
      title: "Description",
      field: "entity.metadata.description",
      render: ({ entity }) => /* @__PURE__ */ React.createElement(
        OverflowTooltip,
        {
          text: entity.metadata.description,
          placement: "bottom-start"
        }
      ),
      width: "auto"
    };
  },
  createTagsColumn() {
    return {
      title: "Tags",
      field: "entity.metadata.tags",
      cellStyle: {
        padding: "0px 16px 0px 20px"
      },
      render: ({ entity }) => /* @__PURE__ */ React.createElement(React.Fragment, null, entity.metadata.tags && entity.metadata.tags.map((t) => /* @__PURE__ */ React.createElement(
        Chip,
        {
          key: t,
          label: t,
          size: "small",
          variant: "outlined",
          style: { marginBottom: "0px" }
        }
      ))),
      width: "auto"
    };
  },
  createTitleColumn(options) {
    return {
      title: "Title",
      field: "entity.metadata.title",
      hidden: options == null ? void 0 : options.hidden,
      searchable: true
    };
  },
  createLabelColumn(key, options) {
    return {
      title: (options == null ? void 0 : options.title) || "Label",
      field: "entity.metadata.labels",
      cellStyle: {
        padding: "0px 16px 0px 20px"
      },
      render: ({ entity }) => {
        var _a;
        const labels = (_a = entity.metadata) == null ? void 0 : _a.labels;
        const specifiedLabelValue = labels && labels[key] || (options == null ? void 0 : options.defaultValue);
        return /* @__PURE__ */ React.createElement(React.Fragment, null, specifiedLabelValue && /* @__PURE__ */ React.createElement(
          Chip,
          {
            key: specifiedLabelValue,
            label: specifiedLabelValue,
            size: "small",
            variant: "outlined"
          }
        ));
      },
      width: "auto"
    };
  },
  createNamespaceColumn() {
    return {
      title: "Namespace",
      field: "entity.metadata.namespace",
      width: "auto"
    };
  }
});

const YellowStar = withStyles({
  root: {
    color: "#f3ba37"
  }
})(Star);
const refCompare = (a, b) => {
  const toRef = (entity) => entity.metadata.title || humanizeEntityRef(entity, {
    defaultKind: "Component"
  });
  return toRef(a).localeCompare(toRef(b));
};
const CatalogTable = (props) => {
  var _a, _b, _c;
  const { columns, actions, tableOptions, subtitle, emptyContent } = props;
  const { isStarredEntity, toggleStarredEntity } = useStarredEntities();
  const { loading, error, entities, filters } = useEntityList();
  const defaultColumns = useMemo(() => {
    var _a2;
    return [
      columnFactories.createTitleColumn({ hidden: true }),
      columnFactories.createNameColumn({ defaultKind: (_a2 = filters.kind) == null ? void 0 : _a2.value }),
      ...createEntitySpecificColumns(),
      columnFactories.createMetadataDescriptionColumn(),
      columnFactories.createTagsColumn()
    ];
    function createEntitySpecificColumns() {
      var _a3;
      const baseColumns = [
        columnFactories.createSystemColumn(),
        columnFactories.createOwnerColumn(),
        columnFactories.createSpecTypeColumn(),
        columnFactories.createSpecLifecycleColumn()
      ];
      switch ((_a3 = filters.kind) == null ? void 0 : _a3.value) {
        case "user":
          return [];
        case "domain":
        case "system":
          return [columnFactories.createOwnerColumn()];
        case "group":
        case "template":
          return [columnFactories.createSpecTypeColumn()];
        case "location":
          return [
            columnFactories.createSpecTypeColumn(),
            columnFactories.createSpecTargetsColumn()
          ];
        default:
          return entities.every(
            (entity) => entity.metadata.namespace === "default"
          ) ? baseColumns : [...baseColumns, columnFactories.createNamespaceColumn()];
      }
    }
  }, [(_a = filters.kind) == null ? void 0 : _a.value, entities]);
  const showTypeColumn = filters.type === void 0;
  const titlePreamble = capitalize((_c = (_b = filters.user) == null ? void 0 : _b.value) != null ? _c : "all");
  if (error) {
    return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(
      WarningPanel,
      {
        severity: "error",
        title: "Could not fetch catalog entities."
      },
      /* @__PURE__ */ React.createElement(CodeSnippet, { language: "text", text: error.toString() })
    ));
  }
  const defaultActions = [
    ({ entity }) => {
      var _a2;
      const url = (_a2 = entity.metadata.annotations) == null ? void 0 : _a2[ANNOTATION_VIEW_URL];
      const title = "View";
      return {
        icon: () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "srOnly" }, title), /* @__PURE__ */ React.createElement(OpenInNew, { fontSize: "small" })),
        tooltip: title,
        disabled: !url,
        onClick: () => {
          if (!url)
            return;
          window.open(url, "_blank");
        }
      };
    },
    ({ entity }) => {
      var _a2;
      const url = (_a2 = entity.metadata.annotations) == null ? void 0 : _a2[ANNOTATION_EDIT_URL];
      const title = "Edit";
      return {
        icon: () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "srOnly" }, title), /* @__PURE__ */ React.createElement(EditIcon, { fontSize: "small" })),
        tooltip: title,
        disabled: !url,
        onClick: () => {
          if (!url)
            return;
          window.open(url, "_blank");
        }
      };
    },
    ({ entity }) => {
      const isStarred = isStarredEntity(entity);
      const title = isStarred ? "Remove from favorites" : "Add to favorites";
      return {
        cellStyle: { paddingLeft: "1em" },
        icon: () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "srOnly" }, title), isStarred ? /* @__PURE__ */ React.createElement(YellowStar, null) : /* @__PURE__ */ React.createElement(StarBorder, null)),
        tooltip: title,
        onClick: () => toggleStarredEntity(entity)
      };
    }
  ];
  const rows = entities.sort(refCompare).map((entity) => {
    const partOfSystemRelations = getEntityRelations(entity, RELATION_PART_OF, {
      kind: "system"
    });
    const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
    return {
      entity,
      resolved: {
        name: humanizeEntityRef(entity, {
          defaultKind: "Component"
        }),
        ownedByRelationsTitle: ownedByRelations.map((r) => humanizeEntityRef(r, { defaultKind: "group" })).join(", "),
        ownedByRelations,
        partOfSystemRelationTitle: partOfSystemRelations.map(
          (r) => humanizeEntityRef(r, {
            defaultKind: "system"
          })
        ).join(", "),
        partOfSystemRelations
      }
    };
  });
  const typeColumn = (columns || defaultColumns).find((c) => c.title === "Type");
  if (typeColumn) {
    typeColumn.hidden = !showTypeColumn;
  }
  const showPagination = rows.length > 20;
  return /* @__PURE__ */ React.createElement(
    Table,
    {
      isLoading: loading,
      columns: columns || defaultColumns,
      options: {
        paging: showPagination,
        pageSize: 20,
        actionsColumnIndex: -1,
        loadingType: "linear",
        showEmptyDataSourceMessage: !loading,
        padding: "dense",
        pageSizeOptions: [20, 50, 100],
        ...tableOptions
      },
      title: `${titlePreamble} (${entities.length})`,
      data: rows,
      actions: actions || defaultActions,
      subtitle,
      emptyContent
    }
  );
};
CatalogTable.columns = columnFactories;

function UnregisterEntity(props) {
  var _a;
  const {
    unregisterEntityOptions,
    isUnregisterAllowed,
    onUnregisterEntity,
    onClose
  } = props;
  const isBoolean = typeof (unregisterEntityOptions == null ? void 0 : unregisterEntityOptions.disableUnregister) === "boolean";
  const isDisabled = (_a = !isUnregisterAllowed || (isBoolean ? !!(unregisterEntityOptions == null ? void 0 : unregisterEntityOptions.disableUnregister) : (unregisterEntityOptions == null ? void 0 : unregisterEntityOptions.disableUnregister) === "disable")) != null ? _a : false;
  let unregisterButton = /* @__PURE__ */ React.createElement(React.Fragment, null);
  if ((unregisterEntityOptions == null ? void 0 : unregisterEntityOptions.disableUnregister) !== "hidden") {
    unregisterButton = /* @__PURE__ */ React.createElement(
      MenuItem,
      {
        onClick: () => {
          onClose();
          onUnregisterEntity();
        },
        disabled: isDisabled
      },
      /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(CancelIcon, { fontSize: "small" })),
      /* @__PURE__ */ React.createElement(ListItemText, { primary: "Unregister entity" })
    );
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, unregisterButton);
}

const useStyles$2 = makeStyles$1(
  (theme) => {
    return {
      button: {
        color: theme.page.fontColor
      }
    };
  },
  { name: "PluginCatalogEntityContextMenu" }
);
function EntityContextMenu(props) {
  const {
    UNSTABLE_extraContextMenuItems,
    UNSTABLE_contextMenuOptions,
    onUnregisterEntity,
    onInspectEntity
  } = props;
  const [anchorEl, setAnchorEl] = useState();
  const classes = useStyles$2();
  const unregisterPermission = useEntityPermission(
    catalogEntityDeletePermission
  );
  const isAllowed = unregisterPermission.allowed;
  const onOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const onClose = () => {
    setAnchorEl(void 0);
  };
  const alertApi = useApi(alertApiRef);
  const copyToClipboard = useCallback(() => {
    window.navigator.clipboard.writeText(window.location.toString()).then(
      () => alertApi.post({
        message: "Copied!",
        severity: "info",
        display: "transient"
      })
    );
  }, [alertApi]);
  const extraItems = UNSTABLE_extraContextMenuItems && [
    ...UNSTABLE_extraContextMenuItems.map((item) => /* @__PURE__ */ React.createElement(
      MenuItem,
      {
        key: item.title,
        onClick: () => {
          onClose();
          item.onClick();
        }
      },
      /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(item.Icon, { fontSize: "small" })),
      /* @__PURE__ */ React.createElement(ListItemText, { primary: item.title })
    )),
    /* @__PURE__ */ React.createElement(Divider, { key: "the divider is here!" })
  ];
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Tooltip, { title: "More", arrow: true }, /* @__PURE__ */ React.createElement(
    IconButton,
    {
      "aria-label": "more",
      "aria-controls": "long-menu",
      "aria-haspopup": "true",
      "aria-expanded": !!anchorEl,
      role: "button",
      onClick: onOpen,
      "data-testid": "menu-button",
      className: classes.button,
      id: "long-menu"
    },
    /* @__PURE__ */ React.createElement(MoreVert, null)
  )), /* @__PURE__ */ React.createElement(
    Popover,
    {
      open: Boolean(anchorEl),
      onClose,
      anchorEl,
      anchorOrigin: { vertical: "bottom", horizontal: "right" },
      transformOrigin: { vertical: "top", horizontal: "right" },
      "aria-labelledby": "long-menu"
    },
    /* @__PURE__ */ React.createElement(MenuList, null, extraItems, /* @__PURE__ */ React.createElement(
      UnregisterEntity,
      {
        unregisterEntityOptions: UNSTABLE_contextMenuOptions,
        isUnregisterAllowed: isAllowed,
        onUnregisterEntity,
        onClose
      }
    ), /* @__PURE__ */ React.createElement(
      MenuItem,
      {
        onClick: () => {
          onClose();
          onInspectEntity();
        }
      },
      /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(BugReportIcon, { fontSize: "small" })),
      /* @__PURE__ */ React.createElement(ListItemText, { primary: "Inspect entity" })
    ), /* @__PURE__ */ React.createElement(
      MenuItem,
      {
        onClick: () => {
          onClose();
          copyToClipboard();
        }
      },
      /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(FileCopyTwoToneIcon, { fontSize: "small" })),
      /* @__PURE__ */ React.createElement(ListItemText, { primary: "Copy entity URL" })
    ))
  ));
}

const dataKey = "plugin.catalog.entityLayoutRoute";
const Route = () => null;
attachComponentData(Route, dataKey, true);
attachComponentData(Route, "core.gatherMountPoints", true);
function EntityLayoutTitle(props) {
  const { entity, title } = props;
  return /* @__PURE__ */ React.createElement(Box, { display: "inline-flex", alignItems: "center", height: "1em", maxWidth: "100%" }, /* @__PURE__ */ React.createElement(
    Box,
    {
      component: "span",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    },
    title
  ), entity && /* @__PURE__ */ React.createElement(FavoriteEntity, { entity }));
}
function headerProps(paramKind, paramNamespace, paramName, entity) {
  var _a, _b, _c, _d, _e;
  const kind = (_a = paramKind != null ? paramKind : entity == null ? void 0 : entity.kind) != null ? _a : "";
  const namespace = (_b = paramNamespace != null ? paramNamespace : entity == null ? void 0 : entity.metadata.namespace) != null ? _b : "";
  const name = (_e = (_d = (_c = entity == null ? void 0 : entity.metadata.title) != null ? _c : paramName) != null ? _d : entity == null ? void 0 : entity.metadata.name) != null ? _e : "";
  return {
    headerTitle: `${name}${namespace && namespace !== DEFAULT_NAMESPACE ? ` in ${namespace}` : ""}`,
    headerType: (() => {
      let t = kind.toLocaleLowerCase("en-US");
      if (entity && entity.spec && "type" in entity.spec) {
        t += " \u2014 ";
        t += entity.spec.type.toLocaleLowerCase("en-US");
      }
      return t;
    })()
  };
}
function EntityLabels(props) {
  var _a;
  const { entity } = props;
  const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, ownedByRelations.length > 0 && /* @__PURE__ */ React.createElement(
    HeaderLabel,
    {
      label: "Owner",
      value: /* @__PURE__ */ React.createElement(
        EntityRefLinks,
        {
          entityRefs: ownedByRelations,
          defaultKind: "Group",
          color: "inherit"
        }
      )
    }
  ), ((_a = entity.spec) == null ? void 0 : _a.lifecycle) && /* @__PURE__ */ React.createElement(HeaderLabel, { label: "Lifecycle", value: entity.spec.lifecycle }));
}
const EntityLayout = (props) => {
  var _a, _b, _c;
  const {
    UNSTABLE_extraContextMenuItems,
    UNSTABLE_contextMenuOptions,
    children,
    NotFoundComponent
  } = props;
  const { kind, namespace, name } = useRouteRefParams(entityRouteRef);
  const { entity, loading, error } = useAsyncEntity();
  const location = useLocation();
  const routes = useElementFilter(
    children,
    (elements) => elements.selectByComponentData({
      key: dataKey,
      withStrictError: "Child of EntityLayout must be an EntityLayout.Route"
    }).getElements().flatMap(({ props: elementProps }) => {
      if (!entity) {
        return [];
      } else if (elementProps.if && !elementProps.if(entity)) {
        return [];
      }
      return [
        {
          path: elementProps.path,
          title: elementProps.title,
          children: elementProps.children,
          tabProps: elementProps.tabProps
        }
      ];
    }),
    [entity]
  );
  const { headerTitle, headerType } = headerProps(
    kind,
    namespace,
    name,
    entity
  );
  const [confirmationDialogOpen, setConfirmationDialogOpen] = useState(false);
  const [inspectionDialogOpen, setInspectionDialogOpen] = useState(false);
  const navigate = useNavigate();
  const cleanUpAfterRemoval = async () => {
    setConfirmationDialogOpen(false);
    setInspectionDialogOpen(false);
    navigate("/");
  };
  useEffect(() => {
    setConfirmationDialogOpen(false);
    setInspectionDialogOpen(false);
  }, [location.pathname]);
  return /* @__PURE__ */ React.createElement(Page, { themeId: (_c = (_b = (_a = entity == null ? void 0 : entity.spec) == null ? void 0 : _a.type) == null ? void 0 : _b.toString()) != null ? _c : "home" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      title: /* @__PURE__ */ React.createElement(EntityLayoutTitle, { title: headerTitle, entity }),
      pageTitleOverride: headerTitle,
      type: headerType
    },
    entity && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(EntityLabels, { entity }), /* @__PURE__ */ React.createElement(
      EntityContextMenu,
      {
        UNSTABLE_extraContextMenuItems,
        UNSTABLE_contextMenuOptions,
        onUnregisterEntity: () => setConfirmationDialogOpen(true),
        onInspectEntity: () => setInspectionDialogOpen(true)
      }
    ))
  ), loading && /* @__PURE__ */ React.createElement(Progress, null), entity && /* @__PURE__ */ React.createElement(RoutedTabs, { routes }), error && /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(Alert, { severity: "error" }, error.toString())), !loading && !error && !entity && /* @__PURE__ */ React.createElement(Content, null, NotFoundComponent ? NotFoundComponent : /* @__PURE__ */ React.createElement(WarningPanel, { title: "Entity not found" }, "There is no ", kind, " with the requested", " ", /* @__PURE__ */ React.createElement(Link, { to: "https://backstage.io/docs/features/software-catalog/references" }, "kind, namespace, and name"), ".")), /* @__PURE__ */ React.createElement(
    UnregisterEntityDialog,
    {
      open: confirmationDialogOpen,
      entity,
      onConfirm: cleanUpAfterRemoval,
      onClose: () => setConfirmationDialogOpen(false)
    }
  ), /* @__PURE__ */ React.createElement(
    InspectEntityDialog,
    {
      open: inspectionDialogOpen,
      entity,
      onClose: () => setInspectionDialogOpen(false)
    }
  ));
};
EntityLayout.Route = Route;

function DeleteEntityDialog(props) {
  const { open, onClose, onConfirm, entity } = props;
  const [busy, setBusy] = useState(false);
  const catalogApi = useApi(catalogApiRef);
  const alertApi = useApi(alertApiRef);
  const onDelete = async () => {
    setBusy(true);
    try {
      const uid = entity.metadata.uid;
      await catalogApi.removeEntityByUid(uid);
      onConfirm();
    } catch (err) {
      assertError(err);
      alertApi.post({ message: err.message });
    } finally {
      setBusy(false);
    }
  };
  return /* @__PURE__ */ React.createElement(Dialog, { open, onClose }, /* @__PURE__ */ React.createElement(DialogTitle, { id: "responsive-dialog-title" }, "Are you sure you want to delete this entity?"), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "secondary",
      disabled: busy,
      onClick: onDelete
    },
    "Delete"
  ), /* @__PURE__ */ React.createElement(Button, { onClick: onClose, color: "primary" }, "Cancel")));
}

function isOrphan(entity) {
  var _a, _b;
  return ((_b = (_a = entity == null ? void 0 : entity.metadata) == null ? void 0 : _a.annotations) == null ? void 0 : _b["backstage.io/orphan"]) === "true";
}
function EntityOrphanWarning() {
  const navigate = useNavigate();
  const catalogLink = useRouteRef(rootRouteRef);
  const [confirmationDialogOpen, setConfirmationDialogOpen] = useState(false);
  const { entity } = useEntity();
  const cleanUpAfterRemoval = async () => {
    setConfirmationDialogOpen(false);
    navigate(catalogLink());
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Alert, { severity: "warning", onClick: () => setConfirmationDialogOpen(true) }, "This entity is not referenced by any location and is therefore not receiving updates. Click here to delete."), /* @__PURE__ */ React.createElement(
    DeleteEntityDialog,
    {
      open: confirmationDialogOpen,
      entity,
      onConfirm: cleanUpAfterRemoval,
      onClose: () => setConfirmationDialogOpen(false)
    }
  ));
}

const errorFilter = (i) => i.error && i.level === "error" && i.type === ENTITY_STATUS_CATALOG_PROCESSING_TYPE;
async function getOwnAndAncestorsErrors(entityRef, catalogApi) {
  const ancestors = await catalogApi.getEntityAncestors({ entityRef });
  const items = ancestors.items.map((item) => {
    var _a, _b;
    const statuses = (_b = (_a = item.entity.status) == null ? void 0 : _a.items) != null ? _b : [];
    const errors = statuses.filter(errorFilter).map((e) => e.error).filter((e) => Boolean(e));
    return { errors, entity: item.entity };
  }).filter((item) => item.errors.length > 0);
  return { items };
}
async function hasCatalogProcessingErrors(entity, context) {
  const catalogApi = context.apis.get(catalogApiRef);
  if (!catalogApi) {
    throw new Error(`No implementation available for ${catalogApiRef}`);
  }
  const errors = await getOwnAndAncestorsErrors(
    stringifyEntityRef(entity),
    catalogApi
  );
  return errors.items.length > 0;
}
function EntityProcessingErrorsPanel() {
  const { entity } = useEntity();
  const entityRef = stringifyEntityRef(entity);
  const catalogApi = useApi(catalogApiRef);
  const { loading, error, value } = useAsync(async () => {
    return getOwnAndAncestorsErrors(entityRef, catalogApi);
  }, [entityRef, catalogApi]);
  if (error) {
    return /* @__PURE__ */ React.createElement(Box, { mb: 1 }, /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error }));
  }
  if (loading || !value) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, value.items.map((ancestorError, index) => /* @__PURE__ */ React.createElement(Box, { key: index, mb: 1 }, stringifyEntityRef(entity) !== stringifyEntityRef(ancestorError.entity) && /* @__PURE__ */ React.createElement(Box, { p: 1 }, "The error below originates from", " ", /* @__PURE__ */ React.createElement(EntityRefLink, { entityRef: ancestorError.entity })), ancestorError.errors.map((e, i) => /* @__PURE__ */ React.createElement(ResponseErrorPanel, { key: i, error: e })))));
}

const ENTITY_SWITCH_KEY = "core.backstage.entitySwitch";
const EntitySwitchCaseComponent = (_props) => null;
attachComponentData(EntitySwitchCaseComponent, ENTITY_SWITCH_KEY, true);
const EntitySwitch = (props) => {
  var _a, _b;
  const { entity, loading } = useAsyncEntity();
  const apis = useApiHolder();
  const results = useElementFilter(
    props.children,
    (collection) => collection.selectByComponentData({
      key: ENTITY_SWITCH_KEY,
      withStrictError: "Child of EntitySwitch is not an EntitySwitch.Case"
    }).getElements().flatMap((element) => {
      if (loading) {
        return [];
      }
      const { if: condition, children: elementsChildren } = element.props;
      if (!entity) {
        return [
          {
            if: condition === void 0,
            children: elementsChildren
          }
        ];
      }
      return [
        {
          if: condition == null ? void 0 : condition(entity, { apis }),
          children: elementsChildren
        }
      ];
    }),
    [apis, entity, loading]
  );
  const hasAsyncCases = results.some(
    (r) => typeof r.if === "object" && "then" in r.if
  );
  if (hasAsyncCases) {
    return /* @__PURE__ */ React.createElement(
      AsyncEntitySwitch,
      {
        results,
        renderMultipleMatches: props.renderMultipleMatches
      }
    );
  }
  if (props.renderMultipleMatches === "all") {
    const children = results.filter((r) => r.if).map((r) => r.children);
    if (children.length === 0) {
      return getDefaultChildren(results);
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
  }
  return (_b = (_a = results.find((r) => r.if)) == null ? void 0 : _a.children) != null ? _b : getDefaultChildren(results);
};
function AsyncEntitySwitch({
  results,
  renderMultipleMatches
}) {
  const { loading, value } = useAsync(async () => {
    var _a;
    const promises = results.map(
      async ({ if: condition, children: output }) => {
        try {
          if (await condition) {
            return output;
          }
        } catch {
        }
        return null;
      }
    );
    if (renderMultipleMatches === "all") {
      const children = (await Promise.all(promises)).filter(Boolean);
      if (children.length === 0) {
        return getDefaultChildren(results);
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
    }
    return (_a = (await Promise.all(promises)).find(Boolean)) != null ? _a : getDefaultChildren(results);
  }, [results]);
  if (loading || !value) {
    return null;
  }
  return value;
}
function getDefaultChildren(results) {
  var _a, _b;
  return (_b = (_a = results.filter((r) => r.if === void 0)[0]) == null ? void 0 : _a.children) != null ? _b : null;
}
EntitySwitch.Case = EntitySwitchCaseComponent;

function strCmp(a, b) {
  return Boolean(
    a && typeof a === "string" && (a == null ? void 0 : a.toLocaleLowerCase("en-US")) === (b == null ? void 0 : b.toLocaleLowerCase("en-US"))
  );
}
function strCmpAll(value, cmpValues) {
  return typeof cmpValues === "string" ? strCmp(value, cmpValues) : cmpValues.length === 0 || cmpValues.some((cmpVal) => strCmp(value, cmpVal));
}
function isKind(kinds) {
  return isEntityWith({ kind: kinds });
}
function isComponentType(types) {
  return isEntityWith({ kind: "component", type: types });
}
function isResourceType(types) {
  return isEntityWith({ kind: "resource", type: types });
}
function isEntityWith(predicate) {
  return (entity) => {
    var _a;
    if (predicate.kind && !strCmpAll(entity.kind, predicate.kind)) {
      return false;
    }
    if (predicate.type && !strCmpAll((_a = entity.spec) == null ? void 0 : _a.type, predicate.type)) {
      return false;
    }
    return true;
  };
}
function isNamespace(namespaces) {
  return (entity) => {
    var _a;
    return strCmpAll((_a = entity.metadata) == null ? void 0 : _a.namespace, namespaces);
  };
}

const FilteredEntityLayout = CatalogFilterLayout;
const FilterContainer = CatalogFilterLayout.Filters;
const EntityListContainer = CatalogFilterLayout.Content;

const ENTITY_YAML = `metadata:
  name: example
  labels:
    javaVersion: 1.2.3`;
const useStyles$1 = makeStyles(
  (theme) => ({
    code: {
      borderRadius: 6,
      margin: `${theme.spacing(2)}px 0px`,
      background: theme.palette.type === "dark" ? "#444" : theme.palette.common.white
    }
  }),
  { name: "PluginCatalogEntityLabelsEmptyState" }
);
function EntityLabelsEmptyState() {
  const classes = useStyles$1();
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body1" }, "No labels defined for this entity. You can add labels to your entity YAML as shown in the highlighted example below:"), /* @__PURE__ */ React.createElement("div", { className: classes.code }, /* @__PURE__ */ React.createElement(
    CodeSnippet,
    {
      text: ENTITY_YAML,
      language: "yaml",
      showLineNumbers: true,
      highlightedNumbers: [3, 4, 5, 6],
      customStyle: { background: "inherit", fontSize: "115%" }
    }
  )), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "primary",
      target: "_blank",
      href: "https://backstage.io/docs/features/software-catalog/descriptor-format#labels-optional"
    },
    "Read more"
  ));
}

const useStyles = makeStyles((_) => ({
  key: {
    fontWeight: "bold"
  }
}));
const EntityLabelsCard$1 = (props) => {
  var _a;
  const { variant, title } = props;
  const { entity } = useEntity();
  const classes = useStyles();
  const columns = [
    {
      render: (row) => {
        return /* @__PURE__ */ React.createElement(Typography, { className: classes.key, variant: "body2" }, row.key);
      }
    },
    {
      field: "value"
    }
  ];
  const labels = (_a = entity == null ? void 0 : entity.metadata) == null ? void 0 : _a.labels;
  return /* @__PURE__ */ React.createElement(InfoCard, { title: title || "Labels", variant }, !labels || Object.keys(labels).length === 0 ? /* @__PURE__ */ React.createElement(EntityLabelsEmptyState, null) : /* @__PURE__ */ React.createElement(
    Table,
    {
      columns,
      data: Object.keys(labels).map((labelKey) => ({
        key: labelKey,
        value: labels[labelKey]
      })),
      options: {
        search: false,
        showTitle: true,
        loadingType: "linear",
        header: false,
        padding: "dense",
        pageSize: 5,
        toolbar: false,
        paging: Object.keys(labels).length > 5
      }
    }
  ));
};

function hasLabels(entity) {
  var _a, _b;
  return ((_a = entity == null ? void 0 : entity.metadata) == null ? void 0 : _a.labels) ? Object.keys((_b = entity == null ? void 0 : entity.metadata) == null ? void 0 : _b.labels).some(Boolean) : false;
}

const catalogPlugin = createPlugin({
  id: "catalog",
  apis: [
    createApiFactory({
      api: catalogApiRef,
      deps: {
        discoveryApi: discoveryApiRef,
        fetchApi: fetchApiRef
      },
      factory: ({ discoveryApi, fetchApi }) => new CatalogClient({ discoveryApi, fetchApi })
    }),
    createApiFactory({
      api: starredEntitiesApiRef,
      deps: { storageApi: storageApiRef },
      factory: ({ storageApi }) => new DefaultStarredEntitiesApi({ storageApi })
    })
  ],
  routes: {
    catalogIndex: rootRouteRef,
    catalogEntity: entityRouteRef
  },
  externalRoutes: {
    createComponent: createComponentRouteRef,
    viewTechDoc: viewTechDocRouteRef
  },
  __experimentalConfigure(options) {
    const defaultOptions = {
      createButtonTitle: "Create"
    };
    return { ...defaultOptions, ...options };
  }
});
const CatalogIndexPage = catalogPlugin.provide(
  createRoutableExtension({
    name: "CatalogIndexPage",
    component: () => import('./index-41f94bc9.esm.js').then((m) => m.CatalogPage),
    mountPoint: rootRouteRef
  })
);
const CatalogEntityPage = catalogPlugin.provide(
  createRoutableExtension({
    name: "CatalogEntityPage",
    component: () => import('./index-f0e32dd1.esm.js').then((m) => m.CatalogEntityPage),
    mountPoint: entityRouteRef
  })
);
const EntityAboutCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityAboutCard",
    component: {
      lazy: () => import('./index-6391c20c.esm.js').then((m) => m.AboutCard)
    }
  })
);
const EntityLinksCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityLinksCard",
    component: {
      lazy: () => import('./index-1c47c3d8.esm.js').then((m) => m.EntityLinksCard)
    }
  })
);
const EntityLabelsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityLabelsCard",
    component: {
      lazy: () => import('./index-37b55325.esm.js').then((m) => m.EntityLabelsCard)
    }
  })
);
const EntityHasSystemsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityHasSystemsCard",
    component: {
      lazy: () => import('./index-a6b7e5a0.esm.js').then((m) => m.HasSystemsCard)
    }
  })
);
const EntityHasComponentsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityHasComponentsCard",
    component: {
      lazy: () => import('./index-62df5b29.esm.js').then((m) => m.HasComponentsCard)
    }
  })
);
const EntityHasSubcomponentsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityHasSubcomponentsCard",
    component: {
      lazy: () => import('./index-796cbb22.esm.js').then(
        (m) => m.HasSubcomponentsCard
      )
    }
  })
);
const EntityHasResourcesCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityHasResourcesCard",
    component: {
      lazy: () => import('./index-579c0e06.esm.js').then((m) => m.HasResourcesCard)
    }
  })
);
const EntityDependsOnComponentsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityDependsOnComponentsCard",
    component: {
      lazy: () => import('./index-84bbec44.esm.js').then(
        (m) => m.DependsOnComponentsCard
      )
    }
  })
);
const EntityDependencyOfComponentsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityDependencyOfComponentsCard",
    component: {
      lazy: () => import('./index-d32ca604.esm.js').then(
        (m) => m.DependencyOfComponentsCard
      )
    }
  })
);
const EntityDependsOnResourcesCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityDependsOnResourcesCard",
    component: {
      lazy: () => import('./index-51c16459.esm.js').then(
        (m) => m.DependsOnResourcesCard
      )
    }
  })
);
const RelatedEntitiesCard = catalogPlugin.provide(
  createComponentExtension({
    name: "RelatedEntitiesCard",
    component: {
      lazy: () => import('./index-60adddb8.esm.js').then(
        (m) => m.RelatedEntitiesCard
      )
    }
  })
);
const CatalogSearchResultListItem = catalogPlugin.provide(
  createSearchResultListItemExtension({
    name: "CatalogSearchResultListItem",
    component: () => import('./index-ccf06d4f.esm.js').then(
      (m) => m.CatalogSearchResultListItem
    ),
    predicate: (result) => result.type === "software-catalog"
  })
);

export { AboutCard as A, isNamespace as B, CatalogTable as C, DefaultStarredEntitiesApi as D, EntityLabelsCard$1 as E, isComponentType as F, isResourceType as G, isEntityWith as H, FilteredEntityLayout as I, FilterContainer as J, EntityListContainer as K, LinksGridList as L, RelatedEntitiesCard as R, AboutContent as a, AboutField as b, createComponentRouteRef as c, CatalogEntityPage as d, CatalogIndexPage as e, catalogPlugin as f, EntityAboutCard as g, hasLabels as h, EntityDependencyOfComponentsCard as i, EntityDependsOnComponentsCard as j, EntityDependsOnResourcesCard as k, EntityHasComponentsCard as l, EntityHasResourcesCard as m, EntityHasSubcomponentsCard as n, EntityHasSystemsCard as o, EntityLinksCard as p, EntityLabelsCard as q, CatalogSearchResultListItem as r, CatalogKindHeader as s, EntityLayout as t, EntityOrphanWarning as u, isOrphan as v, EntityProcessingErrorsPanel as w, hasCatalogProcessingErrors as x, EntitySwitch as y, isKind as z };
//# sourceMappingURL=index-06f6e8ce.esm.js.map
