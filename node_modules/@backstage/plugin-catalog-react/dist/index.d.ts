/// <reference types="react" />
import { CatalogApi } from '@backstage/catalog-client';
export { CATALOG_FILTER_EXISTS, CatalogApi } from '@backstage/catalog-client';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { ApiRef } from '@backstage/core-plugin-api';
import { Observable } from '@backstage/types';
import React, { PropsWithChildren, ReactNode, ComponentProps } from 'react';
import * as _backstage_catalog_model from '@backstage/catalog-model';
import { Entity, CompoundEntityRef } from '@backstage/catalog-model';
import { LinkProps, InfoCardVariants, TableColumn } from '@backstage/core-components';
import { IconButton } from '@material-ui/core';
import { Overrides } from '@material-ui/core/styles/overrides';
import { StyleRules } from '@material-ui/core/styles/withStyles';
import { ScmIntegrationRegistry } from '@backstage/integration';

/**
 * The API reference for the {@link @backstage/catalog-client#CatalogApi}.
 * @public
 */
declare const catalogApiRef: _backstage_core_plugin_api.ApiRef<CatalogApi>;

/**
 * An API to store starred entities
 *
 * @public
 */
declare const starredEntitiesApiRef: ApiRef<StarredEntitiesApi>;
/**
 * An API to store and retrieve starred entities
 *
 * @public
 */
interface StarredEntitiesApi {
    /**
     * Toggle the star state of the entity
     *
     * @param entityRef - an entity reference to toggle
     */
    toggleStarred(entityRef: string): Promise<void>;
    /**
     * Observe the set of starred entity references.
     */
    starredEntitie$(): Observable<Set<string>>;
}

/**
 * An in-memory mock implementation of the StarredEntitiesApi.
 *
 * @public
 */
declare class MockStarredEntitiesApi implements StarredEntitiesApi {
    private readonly starredEntities;
    private readonly subscribers;
    private readonly observable;
    toggleStarred(entityRef: string): Promise<void>;
    starredEntitie$(): Observable<Set<string>>;
}

/** @public */
declare const CatalogFilterLayout: {
    (props: {
        children: React.ReactNode;
    }): JSX.Element;
    Filters: (props: {
        children: React.ReactNode;
    }) => JSX.Element;
    Content: (props: {
        children: React.ReactNode;
    }) => JSX.Element;
};

/**
 * Props for {@link EntityKindPicker}.
 *
 * @public
 */
interface EntityKindPickerProps {
    /**
     * Entity kinds to show in the dropdown; by default all kinds are fetched from the catalog and
     * displayed.
     */
    allowedKinds?: string[];
    initialFilter?: string;
    hidden?: boolean;
}
/** @public */
declare const EntityKindPicker: (props: EntityKindPickerProps) => JSX.Element | null;

/** @public */
type CatalogReactEntityLifecyclePickerClassKey = 'input';
/** @public */
declare const EntityLifecyclePicker: (props: {
    initialFilter?: string[];
}) => JSX.Element | null;

/** @public */
type CatalogReactEntityOwnerPickerClassKey = 'input';
/** @public */
declare const EntityOwnerPicker: () => JSX.Element | null;

/**
 * Props for {@link EntityRefLink}.
 *
 * @public
 */
type EntityRefLinkProps = {
    entityRef: Entity | CompoundEntityRef | string;
    defaultKind?: string;
    title?: string;
    children?: React.ReactNode;
} & Omit<LinkProps, 'to'>;
/**
 * Shows a clickable link to an entity.
 *
 * @public
 */
declare const EntityRefLink: (props: EntityRefLinkProps) => JSX.Element;

/**
 * Props for {@link EntityRefLink}.
 *
 * @public
 */
type EntityRefLinksProps<TRef extends string | CompoundEntityRef | Entity> = ({
    defaultKind?: string;
    entityRefs: TRef[];
    fetchEntities?: false;
    getTitle?(entity: TRef): string | undefined;
} | {
    defaultKind?: string;
    entityRefs: TRef[];
    fetchEntities: true;
    getTitle(entity: Entity): string | undefined;
}) & Omit<LinkProps, 'to'>;
/**
 * Shows a list of clickable links to entities.
 *
 * @public
 */
declare function EntityRefLinks<TRef extends string | CompoundEntityRef | Entity>(props: EntityRefLinksProps<TRef>): JSX.Element;

/**
 * @param defaultNamespace - if set to false then namespace is never omitted,
 * if set to string which matches namespace of entity then omitted
 *
 * @public */
declare function humanizeEntityRef(entityRef: Entity | CompoundEntityRef, opts?: {
    defaultKind?: string;
    defaultNamespace?: string | false;
}): string;

/**
 * Properties for an entity popover on hover of a component.
 *
 * @public
 */
type EntityPeekAheadPopoverProps = PropsWithChildren<{
    entityRef: string;
    delayTime?: number;
}>;
/**
 * Shows an entity popover on hover of a component.
 *
 * @public
 */
declare const EntityPeekAheadPopover: (props: EntityPeekAheadPopoverProps) => JSX.Element;

/** @public */
type CatalogReactEntitySearchBarClassKey = 'searchToolbar' | 'input';
/**
 * Renders search bar for filtering the entity list.
 * @public
 */
declare const EntitySearchBar: () => JSX.Element;

/**
 * Props for {@link EntityTable}.
 *
 * @public
 */
interface EntityTableProps<T extends Entity> {
    title: string;
    variant?: InfoCardVariants;
    entities: T[];
    emptyContent?: ReactNode;
    columns: TableColumn<T>[];
}
/**
 * A general entity table component, that can be used for composing more
 * specific entity tables.
 *
 * @public
 */
declare const EntityTable: {
    <T extends Entity>(props: EntityTableProps<T>): JSX.Element;
    columns: Readonly<{
        createEntityRefColumn<T_1 extends Entity>(options: {
            defaultKind?: string | undefined;
        }): TableColumn<T_1>;
        createEntityRelationColumn<T_2 extends Entity>(options: {
            title: string;
            relation: string;
            defaultKind?: string | undefined;
            filter?: {
                kind: string;
            } | undefined;
        }): TableColumn<T_2>;
        createOwnerColumn<T_3 extends Entity>(): TableColumn<T_3>;
        createDomainColumn<T_4 extends Entity>(): TableColumn<T_4>;
        createSystemColumn<T_5 extends Entity>(): TableColumn<T_5>;
        createMetadataDescriptionColumn<T_6 extends Entity>(): TableColumn<T_6>;
        createSpecLifecycleColumn<T_7 extends Entity>(): TableColumn<T_7>;
        createSpecTypeColumn<T_8 extends Entity>(): TableColumn<T_8>;
    }>;
    systemEntityColumns: TableColumn<_backstage_catalog_model.SystemEntity>[];
    componentEntityColumns: TableColumn<_backstage_catalog_model.ComponentEntity>[];
};

/** @public */
declare const columnFactories: Readonly<{
    createEntityRefColumn<T extends Entity>(options: {
        defaultKind?: string;
    }): TableColumn<T>;
    createEntityRelationColumn<T_1 extends Entity>(options: {
        title: string;
        relation: string;
        defaultKind?: string;
        filter?: {
            kind: string;
        };
    }): TableColumn<T_1>;
    createOwnerColumn<T_2 extends Entity>(): TableColumn<T_2>;
    createDomainColumn<T_3 extends Entity>(): TableColumn<T_3>;
    createSystemColumn<T_4 extends Entity>(): TableColumn<T_4>;
    createMetadataDescriptionColumn<T_5 extends Entity>(): TableColumn<T_5>;
    createSpecLifecycleColumn<T_6 extends Entity>(): TableColumn<T_6>;
    createSpecTypeColumn<T_7 extends Entity>(): TableColumn<T_7>;
}>;

/** @public */
type CatalogReactEntityTagPickerClassKey = 'input';
/** @public */
type EntityTagPickerProps = {
    showCounts?: boolean;
};
/** @public */
declare const EntityTagPicker: (props: EntityTagPickerProps) => JSX.Element;

/**
 * Props for {@link EntityTypePicker}.
 *
 * @public
 */
interface EntityTypePickerProps {
    initialFilter?: string;
    hidden?: boolean;
}
/** @public */
declare const EntityTypePicker: (props: EntityTypePickerProps) => JSX.Element | null;

/** @public */
type FavoriteEntityProps = ComponentProps<typeof IconButton> & {
    entity: Entity;
};
/**
 * IconButton for showing if a current entity is starred and adding/removing it from the favorite entities
 * @param props - MaterialUI IconButton props extended by required `entity` prop
 * @public
 */
declare const FavoriteEntity: (props: FavoriteEntityProps) => JSX.Element;

/**
 * A dialog that lets users inspect the low level details of their entities.
 *
 * @public
 */
declare function InspectEntityDialog(props: {
    open: boolean;
    entity: Entity;
    onClose: () => void;
}): JSX.Element | null;

/** @public */
type UnregisterEntityDialogProps = {
    open: boolean;
    onConfirm: () => any;
    onClose: () => any;
    entity: Entity;
};
/** @public */
declare const UnregisterEntityDialog: (props: UnregisterEntityDialogProps) => JSX.Element;

/** @public */
type EntityFilter = {
    /**
     * Get filters to add to the catalog-backend request. These are a dot-delimited field with
     * value(s) to accept, extracted on the backend by parseEntityFilterParams. For example:
     *   `{ field: 'kind', values: ['component'] }`
     *   `{ field: 'metadata.name', values: ['component-1', 'component-2'] }`
     */
    getCatalogFilters?: () => Record<string, string | symbol | (string | symbol)[]>;
    /**
     * Filter entities on the frontend after a catalog-backend request. This function will be called
     * with each backend-resolved entity. This is used when frontend information is required for
     * filtering, such as a user's starred entities.
     */
    filterEntity?: (entity: Entity) => boolean;
    /**
     * Serialize the filter value to a string for query params. The UI component responsible for
     * handling this filter should retrieve this from useEntityList.queryParameters. The
     * value restored should be in the precedence: queryParameters `>` initialValue prop `>` default.
     */
    toQueryValue?: () => string | string[];
};
/** @public */
type UserListFilterKind = 'owned' | 'starred' | 'all';

/** @public */
type CatalogReactUserListPickerClassKey = 'root' | 'title' | 'listIcon' | 'menuItem' | 'groupWrapper';
/** @public */
type UserListPickerProps = {
    initialFilter?: UserListFilterKind;
    availableFilters?: UserListFilterKind[];
};
/** @public */
declare const UserListPicker: (props: UserListPickerProps) => JSX.Element;

/** @public */
type CatalogReactEntityProcessingStatusPickerClassKey = 'input';
/** @public */
declare const EntityProcessingStatusPicker: () => JSX.Element;

/** @public */
type CatalogReactEntityNamespacePickerClassKey = 'input';
/** @public */
declare const EntityNamespacePicker: () => JSX.Element;

/** @public */
type EntityLoadingStatus<TEntity extends Entity = Entity> = {
    entity?: TEntity;
    loading: boolean;
    error?: Error;
    refresh?: VoidFunction;
};
/**
 * Properties for the AsyncEntityProvider component.
 *
 * @public
 */
interface AsyncEntityProviderProps {
    children: ReactNode;
    entity?: Entity;
    loading: boolean;
    error?: Error;
    refresh?: VoidFunction;
}
/**
 * Provides a loaded entity to be picked up by the `useEntity` hook.
 *
 * @public
 */
declare const AsyncEntityProvider: (props: AsyncEntityProviderProps) => JSX.Element;
/**
 * Properties for the EntityProvider component.
 *
 * @public
 */
interface EntityProviderProps {
    children: ReactNode;
    entity?: Entity;
}
/**
 * Provides an entity to be picked up by the `useEntity` hook.
 *
 * @public
 */
declare const EntityProvider: (props: EntityProviderProps) => JSX.Element;
/**
 * Grab the current entity from the context, throws if the entity has not yet been loaded
 * or is not available.
 *
 * @public
 */
declare function useEntity<TEntity extends Entity = Entity>(): {
    entity: TEntity;
};
/**
 * Grab the current entity from the context, provides loading state and errors, and the ability to refresh.
 *
 * @public
 */
declare function useAsyncEntity<TEntity extends Entity = Entity>(): EntityLoadingStatus<TEntity>;

/**
 * Filter entities based on Kind.
 * @public
 */
declare class EntityKindFilter implements EntityFilter {
    readonly value: string;
    constructor(value: string);
    getCatalogFilters(): Record<string, string | string[]>;
    toQueryValue(): string;
}
/**
 * Filters entities based on type
 * @public
 */
declare class EntityTypeFilter implements EntityFilter {
    readonly value: string | string[];
    constructor(value: string | string[]);
    getTypes(): string[];
    getCatalogFilters(): Record<string, string | string[]>;
    toQueryValue(): string[];
}
/**
 * Filters entities based on tag.
 * @public
 */
declare class EntityTagFilter implements EntityFilter {
    readonly values: string[];
    constructor(values: string[]);
    filterEntity(entity: Entity): boolean;
    toQueryValue(): string[];
}
/**
 * Filters entities where the text matches spec, title or tags.
 * @public
 */
declare class EntityTextFilter implements EntityFilter {
    readonly value: string;
    constructor(value: string);
    filterEntity(entity: Entity): boolean;
    private toUpperArray;
}
/**
 * Filter matching entities that are owned by group.
 * @public
 *
 * CAUTION: This class may contain both full and partial entity refs.
 */
declare class EntityOwnerFilter implements EntityFilter {
    readonly values: string[];
    constructor(values: string[]);
    filterEntity(entity: Entity): boolean;
    /**
     * Get the URL query parameter value. May be a mix of full and humanized entity refs.
     * @returns list of entity refs.
     */
    toQueryValue(): string[];
}
/**
 * Filters entities on lifecycle.
 * @public
 */
declare class EntityLifecycleFilter implements EntityFilter {
    readonly values: string[];
    constructor(values: string[]);
    filterEntity(entity: Entity): boolean;
    toQueryValue(): string[];
}
/**
 * Filters entities to those within the given namespace(s).
 * @public
 */
declare class EntityNamespaceFilter implements EntityFilter {
    readonly values: string[];
    constructor(values: string[]);
    filterEntity(entity: Entity): boolean;
    toQueryValue(): string[];
}
/**
 * Filters entities based on whatever the user has starred or owns them.
 * @public
 */
declare class UserListFilter implements EntityFilter {
    readonly value: UserListFilterKind;
    readonly isOwnedEntity: (entity: Entity) => boolean;
    readonly isStarredEntity: (entity: Entity) => boolean;
    constructor(value: UserListFilterKind, isOwnedEntity: (entity: Entity) => boolean, isStarredEntity: (entity: Entity) => boolean);
    filterEntity(entity: Entity): boolean;
    toQueryValue(): string;
}
/**
 * Filters entities based if it is an orphan or not.
 * @public
 */
declare class EntityOrphanFilter implements EntityFilter {
    readonly value: boolean;
    constructor(value: boolean);
    filterEntity(entity: Entity): boolean;
}
/**
 * Filters entities based on if it has errors or not.
 * @public
 */
declare class EntityErrorFilter implements EntityFilter {
    readonly value: boolean;
    constructor(value: boolean);
    filterEntity(entity: Entity): boolean;
}

/** @public */
type DefaultEntityFilters = {
    kind?: EntityKindFilter;
    type?: EntityTypeFilter;
    user?: UserListFilter;
    owners?: EntityOwnerFilter;
    lifecycles?: EntityLifecycleFilter;
    tags?: EntityTagFilter;
    text?: EntityTextFilter;
    orphan?: EntityOrphanFilter;
    error?: EntityErrorFilter;
    namespace?: EntityNamespaceFilter;
};
/** @public */
type EntityListContextProps<EntityFilters extends DefaultEntityFilters = DefaultEntityFilters> = {
    /**
     * The currently registered filters, adhering to the shape of DefaultEntityFilters or an extension
     * of that default (to add custom filter types).
     */
    filters: EntityFilters;
    /**
     * The resolved list of catalog entities, after all filters are applied.
     */
    entities: Entity[];
    /**
     * The resolved list of catalog entities, after _only catalog-backend_ filters are applied.
     */
    backendEntities: Entity[];
    /**
     * Update one or more of the registered filters. Optional filters can be set to `undefined` to
     * reset the filter.
     */
    updateFilters: (filters: Partial<EntityFilters> | ((prevFilters: EntityFilters) => Partial<EntityFilters>)) => void;
    /**
     * Filter values from query parameters.
     */
    queryParameters: Partial<Record<keyof EntityFilters, string | string[]>>;
    loading: boolean;
    error?: Error;
};
/**
 * Creates new context for entity listing and filtering.
 * @public
 */
declare const EntityListContext: React.Context<EntityListContextProps<any> | undefined>;
/**
 * Provides entities and filters for a catalog listing.
 * @public
 */
declare const EntityListProvider: <EntityFilters extends DefaultEntityFilters>(props: PropsWithChildren<{}>) => JSX.Element;
/**
 * Hook for interacting with the entity list context provided by the {@link EntityListProvider}.
 * @public
 */
declare function useEntityList<EntityFilters extends DefaultEntityFilters = DefaultEntityFilters>(): EntityListContextProps<EntityFilters>;

/**
 * A hook built on top of `useEntityList` for enabling selection of valid `spec.type` values
 * based on the selected EntityKindFilter.
 * @public
 */
declare function useEntityTypeFilter(): {
    loading: boolean;
    error?: Error;
    availableTypes: string[];
    selectedTypes: string[];
    setSelectedTypes: (types: string[]) => void;
};

/** @public */
declare function useRelatedEntities(entity: Entity, relationFilter: {
    type?: string;
    kind?: string;
}): {
    entities: Entity[] | undefined;
    loading: boolean;
    error: Error | undefined;
};

/** @public */
declare function useStarredEntities(): {
    starredEntities: Set<string>;
    toggleStarredEntity: (entityOrRef: Entity | CompoundEntityRef | string) => void;
    isStarredEntity: (entityOrRef: Entity | CompoundEntityRef | string) => boolean;
};

/** @public */
declare function useStarredEntity(entityOrRef: Entity | CompoundEntityRef | string): {
    toggleStarredEntity: () => void;
    isStarredEntity: boolean;
};

/**
 * Returns a function that checks whether the currently signed-in user is an
 * owner of a given entity. When the hook is initially mounted, the loading
 * flag will be true and the results returned from the function will always be
 * false.
 *
 * @public
 *
 * @returns a function that checks if the signed in user owns an entity
 */
declare function useEntityOwnership(): {
    loading: boolean;
    isOwnedEntity: (entity: Entity) => boolean;
};

/**
 * A stable route ref that points to the catalog page for an individual entity.
 *
 * This `RouteRef` can be imported and used directly, and does not need to be referenced
 * via an `ExternalRouteRef`.
 *
 * If you want to replace the `EntityPage` from `@backstage/catalog-plugin` in your app,
 * you need to use the `entityRouteRef` as the mount point instead of your own.
 * @public
 */
declare const entityRouteRef: _backstage_core_plugin_api.RouteRef<{
    name: string;
    kind: string;
    namespace: string;
}>;
/**
 * Utility function to get suitable route params for entityRoute, given an
 * @public
 */
declare function entityRouteParams(entity: Entity): {
    readonly kind: string;
    readonly namespace: string;
    readonly name: string;
};

/** @public */
declare function MockEntityListContextProvider<T extends DefaultEntityFilters = DefaultEntityFilters>(props: PropsWithChildren<{
    value?: Partial<EntityListContextProps<T>>;
}>): JSX.Element;

/** @public */
type CatalogReactComponentsNameToClassKey = {
    CatalogReactUserListPicker: CatalogReactUserListPickerClassKey;
    CatalogReactEntityLifecyclePicker: CatalogReactEntityLifecyclePickerClassKey;
    CatalogReactEntitySearchBar: CatalogReactEntitySearchBarClassKey;
    CatalogReactEntityTagPicker: CatalogReactEntityTagPickerClassKey;
    CatalogReactEntityOwnerPicker: CatalogReactEntityOwnerPickerClassKey;
    CatalogReactEntityProcessingStatusPicker: CatalogReactEntityProcessingStatusPickerClassKey;
};
/** @public */
type BackstageOverrides = Overrides & {
    [Name in keyof CatalogReactComponentsNameToClassKey]?: Partial<StyleRules<CatalogReactComponentsNameToClassKey[Name]>>;
};

/**
 * Get the related entity references.
 *
 * @public
 */
declare function getEntityRelations(entity: Entity | undefined, relationType: string, filter?: {
    kind: string;
}): CompoundEntityRef[];

/** @public */
type EntitySourceLocation = {
    locationTargetUrl: string;
    integrationType?: string;
};
/** @public */
declare function getEntitySourceLocation(entity: Entity, scmIntegrationsApi: ScmIntegrationRegistry): EntitySourceLocation | undefined;

export { AsyncEntityProvider, AsyncEntityProviderProps, BackstageOverrides, CatalogFilterLayout, CatalogReactComponentsNameToClassKey, CatalogReactEntityLifecyclePickerClassKey, CatalogReactEntityNamespacePickerClassKey, CatalogReactEntityOwnerPickerClassKey, CatalogReactEntityProcessingStatusPickerClassKey, CatalogReactEntitySearchBarClassKey, CatalogReactEntityTagPickerClassKey, CatalogReactUserListPickerClassKey, DefaultEntityFilters, EntityErrorFilter, EntityFilter, EntityKindFilter, EntityKindPicker, EntityKindPickerProps, EntityLifecycleFilter, EntityLifecyclePicker, EntityListContext, EntityListContextProps, EntityListProvider, EntityLoadingStatus, EntityNamespaceFilter, EntityNamespacePicker, EntityOrphanFilter, EntityOwnerFilter, EntityOwnerPicker, EntityPeekAheadPopover, EntityPeekAheadPopoverProps, EntityProcessingStatusPicker, EntityProvider, EntityProviderProps, EntityRefLink, EntityRefLinkProps, EntityRefLinks, EntityRefLinksProps, EntitySearchBar, EntitySourceLocation, EntityTable, EntityTableProps, EntityTagFilter, EntityTagPicker, EntityTagPickerProps, EntityTextFilter, EntityTypeFilter, EntityTypePicker, EntityTypePickerProps, FavoriteEntity, FavoriteEntityProps, InspectEntityDialog, MockEntityListContextProvider, MockStarredEntitiesApi, StarredEntitiesApi, UnregisterEntityDialog, UnregisterEntityDialogProps, UserListFilter, UserListFilterKind, UserListPicker, UserListPickerProps, catalogApiRef, columnFactories, entityRouteParams, entityRouteRef, getEntityRelations, getEntitySourceLocation, humanizeEntityRef, starredEntitiesApiRef, useAsyncEntity, useEntity, useEntityList, useEntityOwnership, useEntityTypeFilter, useRelatedEntities, useStarredEntities, useStarredEntity };
