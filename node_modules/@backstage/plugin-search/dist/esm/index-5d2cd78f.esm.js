import { useContent, Link, SidebarSearchField } from '@backstage/core-components';
import { createRouteRef, createPlugin, createApiFactory, discoveryApiRef, identityApiRef, createRoutableExtension, createComponentExtension, useRouteRef, useApi } from '@backstage/core-plugin-api';
import { searchApiRef, SearchContextProvider, useSearch, SearchBar, SearchResult, SearchResultPager } from '@backstage/plugin-search-react';
import { Dialog, useTheme, DialogTitle, DialogContent, Grid, Divider, DialogActions, makeStyles as makeStyles$1, Card, CardHeader, CardContent, Accordion, AccordionSummary, AccordionDetails, List, ListItem, ListItemIcon, ListItemText, Tabs, Tab, FormControl, InputLabel, Select, Chip, MenuItem, Checkbox } from '@material-ui/core';
import Box from '@material-ui/core/Box';
import Button from '@material-ui/core/Button';
import IconButton from '@material-ui/core/IconButton';
import { makeStyles } from '@material-ui/core/styles';
import ArrowForwardIcon from '@material-ui/icons/ArrowForward';
import CloseIcon from '@material-ui/icons/Close';
import React, { useRef, useEffect, useCallback, useState, useContext, Fragment, cloneElement } from 'react';
import { useNavigate, useLocation, useOutlet } from 'react-router-dom';
import { ResponseError } from '@backstage/errors';
import qs from 'qs';
import { createVersionedContext, createVersionedValueMap } from '@backstage/version-bridge';
import useUpdateEffect from 'react-use/lib/useUpdateEffect';
import usePrevious from 'react-use/lib/usePrevious';
import useEffectOnce from 'react-use/lib/useEffectOnce';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import AllIcon from '@material-ui/icons/FontDownload';
import useAsync from 'react-use/lib/useAsync';

class SearchClient {
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
    this.identityApi = options.identityApi;
  }
  async query(query) {
    const { token } = await this.identityApi.getCredentials();
    const queryString = qs.stringify(query);
    const url = `${await this.discoveryApi.getBaseUrl(
      "search"
    )}/query?${queryString}`;
    const response = await fetch(url, {
      headers: token ? { Authorization: `Bearer ${token}` } : {}
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return response.json();
  }
}

const rootRouteRef = createRouteRef({
  id: "search"
});
const searchPlugin = createPlugin({
  id: "search",
  apis: [
    createApiFactory({
      api: searchApiRef,
      deps: { discoveryApi: discoveryApiRef, identityApi: identityApiRef },
      factory: ({ discoveryApi, identityApi }) => {
        return new SearchClient({ discoveryApi, identityApi });
      }
    })
  ],
  routes: {
    root: rootRouteRef
  }
});
const SearchPage$1 = searchPlugin.provide(
  createRoutableExtension({
    name: "SearchPage",
    component: () => import('./index-7373522b.esm.js').then((m) => m.SearchPage),
    mountPoint: rootRouteRef
  })
);
const SidebarSearchModal = searchPlugin.provide(
  createComponentExtension({
    name: "SidebarSearchModal",
    component: {
      lazy: () => import('./index-3baceccb.esm.js').then(
        (m) => m.SidebarSearchModal
      )
    }
  })
);
const HomePageSearchBar = searchPlugin.provide(
  createComponentExtension({
    name: "HomePageSearchBar",
    component: {
      lazy: () => import('./index-772750bd.esm.js').then((m) => m.HomePageSearchBar)
    }
  })
);

const useStyles$3 = makeStyles((theme) => ({
  dialogTitle: {
    gap: theme.spacing(1),
    display: "grid",
    alignItems: "center",
    gridTemplateColumns: "1fr auto",
    "&> button": {
      marginTop: theme.spacing(1)
    }
  },
  input: {
    flex: 1
  },
  // Reduces default height of the modal, keeping a gap of 128px between the top and bottom of the page.
  paperFullWidth: { height: "calc(100% - 128px)" },
  dialogActionsContainer: { padding: theme.spacing(1, 3) },
  viewResultsLink: { verticalAlign: "0.5em" }
}));
const Modal = ({ toggleModal }) => {
  const classes = useStyles$3();
  const navigate = useNavigate();
  const { transitions } = useTheme();
  const { focusContent } = useContent();
  const { term } = useSearch();
  const searchBarRef = useRef(null);
  const searchPagePath = `${useRouteRef(rootRouteRef)()}?query=${term}`;
  useEffect(() => {
    var _a;
    (_a = searchBarRef == null ? void 0 : searchBarRef.current) == null ? void 0 : _a.focus();
  });
  const handleSearchResultClick = useCallback(() => {
    setTimeout(focusContent, transitions.duration.leavingScreen);
  }, [focusContent, transitions]);
  const handleSearchBarKeyDown = useCallback(
    (e) => {
      if (e.key === "Enter") {
        navigate(searchPagePath);
        handleSearchResultClick();
      }
    },
    [navigate, handleSearchResultClick, searchPagePath]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogTitle, null, /* @__PURE__ */ React.createElement(Box, { className: classes.dialogTitle }, /* @__PURE__ */ React.createElement(
    SearchBar,
    {
      className: classes.input,
      inputProps: { ref: searchBarRef },
      onKeyDown: handleSearchBarKeyDown
    }
  ), /* @__PURE__ */ React.createElement(IconButton, { "aria-label": "close", onClick: toggleModal }, /* @__PURE__ */ React.createElement(CloseIcon, null)))), /* @__PURE__ */ React.createElement(DialogContent, null, /* @__PURE__ */ React.createElement(
    Grid,
    {
      container: true,
      direction: "row-reverse",
      justifyContent: "flex-start",
      alignItems: "center"
    },
    /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(
      Button,
      {
        to: searchPagePath,
        onClick: handleSearchResultClick,
        endIcon: /* @__PURE__ */ React.createElement(ArrowForwardIcon, null),
        component: Link,
        color: "primary"
      },
      "View Full Results"
    ))
  ), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(
    SearchResult,
    {
      onClick: handleSearchResultClick,
      onKeyDown: handleSearchResultClick
    }
  )), /* @__PURE__ */ React.createElement(DialogActions, { className: classes.dialogActionsContainer }, /* @__PURE__ */ React.createElement(Grid, { container: true, direction: "row" }, /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12 }, /* @__PURE__ */ React.createElement(SearchResultPager, null)))));
};
const SearchModal = (props) => {
  var _a;
  const { open = true, hidden, toggleModal, children } = props;
  const classes = useStyles$3();
  return /* @__PURE__ */ React.createElement(
    Dialog,
    {
      classes: {
        paperFullWidth: classes.paperFullWidth
      },
      onClose: toggleModal,
      "aria-labelledby": "search-modal-title",
      fullWidth: true,
      maxWidth: "lg",
      open,
      hidden
    },
    open && /* @__PURE__ */ React.createElement(SearchContextProvider, { inheritParentContextIfAvailable: true }, (_a = children && children({ toggleModal })) != null ? _a : /* @__PURE__ */ React.createElement(Modal, { toggleModal }))
  );
};

const SearchModalContext = createVersionedContext("search-modal-context");
const SearchModalProvider = (props) => {
  const value = useSearchModal(props.showInitially);
  const versionedValue = createVersionedValueMap({ 1: value });
  return /* @__PURE__ */ React.createElement(SearchModalContext.Provider, { value: versionedValue }, props.children);
};
function useSearchModal(initialState = false) {
  const [state, setState] = useState({
    hidden: !initialState,
    open: initialState
  });
  const toggleModal = useCallback(
    () => setState((prevState) => ({
      open: true,
      hidden: !prevState.hidden
    })),
    []
  );
  const setOpen = useCallback(
    (open) => setState((prevState) => ({
      open: prevState.open || open,
      hidden: !open
    })),
    []
  );
  const parentContext = useContext(SearchModalContext);
  const parentContextValue = parentContext == null ? void 0 : parentContext.atVersion(1);
  const isParentContextPresent = !!(parentContextValue == null ? void 0 : parentContextValue.state);
  const location = useLocation();
  const locationKey = `${location.pathname}${location.search}${location.hash}`;
  useUpdateEffect(() => {
    setState((prevState) => ({
      open: prevState.open,
      hidden: true
    }));
  }, [locationKey]);
  return isParentContextPresent ? parentContextValue : { state, toggleModal, setOpen };
}

const UrlUpdater = () => {
  const location = useLocation();
  const {
    term,
    setTerm,
    types,
    setTypes,
    pageCursor,
    setPageCursor,
    filters,
    setFilters
  } = useSearch();
  const prevQueryParams = usePrevious(location.search);
  useEffect(() => {
    if (location.search === prevQueryParams) {
      return;
    }
    const query = qs.parse(location.search.substring(1), { arrayLimit: 0 }) || {};
    if (query.filters) {
      setFilters(query.filters);
    }
    if (query.query) {
      setTerm(query.query);
    }
    if (query.pageCursor) {
      setPageCursor(query.pageCursor);
    }
    if (query.types) {
      setTypes(query.types);
    }
  }, [prevQueryParams, location, setTerm, setTypes, setPageCursor, setFilters]);
  useEffect(() => {
    const newParams = qs.stringify(
      {
        query: term,
        types,
        pageCursor,
        filters
      },
      { arrayFormat: "brackets" }
    );
    const newUrl = `${window.location.pathname}?${newParams}`;
    window.history.replaceState(null, document.title, newUrl);
  }, [term, types, pageCursor, filters]);
  return null;
};
const SearchPage = () => {
  const outlet = useOutlet();
  return /* @__PURE__ */ React.createElement(SearchContextProvider, null, /* @__PURE__ */ React.createElement(UrlUpdater, null), outlet);
};

const useStyles$2 = makeStyles$1((theme) => ({
  card: {
    backgroundColor: "rgba(0, 0, 0, .11)"
  },
  cardContent: {
    paddingTop: theme.spacing(1)
  },
  icon: {
    color: theme.palette.common.black
  },
  list: {
    width: "100%"
  },
  listItemIcon: {
    width: "24px",
    height: "24px"
  },
  accordion: {
    backgroundColor: theme.palette.background.paper
  },
  accordionSummary: {
    minHeight: "auto",
    "&.Mui-expanded": {
      minHeight: "auto"
    }
  },
  accordionSummaryContent: {
    margin: theme.spacing(2, 0),
    "&.Mui-expanded": {
      margin: theme.spacing(2, 0)
    }
  },
  accordionDetails: {
    padding: theme.spacing(0, 0, 1)
  }
}));
const SearchTypeAccordion = (props) => {
  const classes = useStyles$2();
  const { filters, setPageCursor, setTypes, term, types } = useSearch();
  const searchApi = useApi(searchApiRef);
  const [expanded, setExpanded] = useState(true);
  const { defaultValue, name, showCounts, types: givenTypes } = props;
  const toggleExpanded = () => setExpanded((prevState) => !prevState);
  const handleClick = (type) => {
    return () => {
      setTypes(type !== "" ? [type] : []);
      setPageCursor(void 0);
      setExpanded(false);
    };
  };
  useEffect(() => {
    if (defaultValue) {
      setTypes([defaultValue]);
    }
  }, []);
  const definedTypes = [
    {
      value: "",
      name: "All",
      icon: /* @__PURE__ */ React.createElement(AllIcon, null)
    },
    ...givenTypes
  ];
  const selected = types[0] || "";
  const { value: resultCounts } = useAsync(async () => {
    if (!showCounts) {
      return {};
    }
    const counts = await Promise.all(
      definedTypes.map((t) => t.value).map(async (type) => {
        const { numberOfResults } = await searchApi.query({
          term,
          types: type ? [type] : [],
          filters: types.includes(type) || !types.length && !type ? filters : {},
          pageLimit: 0
        });
        return [
          type,
          numberOfResults !== void 0 ? `${numberOfResults >= 1e4 ? `>10000` : numberOfResults} results` : " -- "
        ];
      })
    );
    return Object.fromEntries(counts);
  }, [filters, showCounts, term, types]);
  return /* @__PURE__ */ React.createElement(Card, { className: classes.card }, /* @__PURE__ */ React.createElement(CardHeader, { title: name, titleTypographyProps: { variant: "overline" } }), /* @__PURE__ */ React.createElement(CardContent, { className: classes.cardContent }, /* @__PURE__ */ React.createElement(
    Accordion,
    {
      className: classes.accordion,
      expanded,
      onChange: toggleExpanded
    },
    /* @__PURE__ */ React.createElement(
      AccordionSummary,
      {
        classes: {
          root: classes.accordionSummary,
          content: classes.accordionSummaryContent
        },
        expandIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, { className: classes.icon }),
        IconButtonProps: { size: "small" }
      },
      expanded ? "Collapse" : definedTypes.filter((t) => t.value === selected)[0].name
    ),
    /* @__PURE__ */ React.createElement(AccordionDetails, { classes: { root: classes.accordionDetails } }, /* @__PURE__ */ React.createElement(
      List,
      {
        className: classes.list,
        component: "nav",
        "aria-label": "filter by type",
        disablePadding: true,
        dense: true
      },
      definedTypes.map((type) => /* @__PURE__ */ React.createElement(Fragment, { key: type.value }, /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(
        ListItem,
        {
          selected: types[0] === type.value || types.length === 0 && type.value === "",
          onClick: handleClick(type.value),
          button: true
        },
        /* @__PURE__ */ React.createElement(ListItemIcon, null, cloneElement(type.icon, {
          className: classes.listItemIcon
        })),
        /* @__PURE__ */ React.createElement(
          ListItemText,
          {
            primary: type.name,
            secondary: resultCounts && resultCounts[type.value]
          }
        )
      )))
    ))
  )));
};

const useStyles$1 = makeStyles$1((theme) => ({
  tabs: {
    borderBottom: `1px solid ${theme.palette.textVerySubtle}`
  },
  tab: {
    height: "50px",
    fontWeight: theme.typography.fontWeightBold,
    fontSize: theme.typography.pxToRem(13),
    color: theme.palette.text.primary,
    minWidth: "130px"
  }
}));
const SearchTypeTabs = (props) => {
  const classes = useStyles$1();
  const { setPageCursor, setTypes, types } = useSearch();
  const { defaultValue, types: givenTypes } = props;
  const changeTab = (_, newType) => {
    setTypes(newType !== "" ? [newType] : []);
    setPageCursor(void 0);
  };
  useEffect(() => {
    if (defaultValue) {
      setTypes([defaultValue]);
    }
  }, []);
  const definedTypes = [
    {
      value: "",
      name: "All"
    },
    ...givenTypes
  ];
  return /* @__PURE__ */ React.createElement(
    Tabs,
    {
      "aria-label": "List of search types tabs",
      className: classes.tabs,
      indicatorColor: "primary",
      value: types.length === 0 ? "" : types[0],
      onChange: changeTab
    },
    definedTypes.map((type, idx) => /* @__PURE__ */ React.createElement(
      Tab,
      {
        key: idx,
        className: classes.tab,
        label: type.name,
        value: type.value
      }
    ))
  );
};

const useStyles = makeStyles$1((theme) => ({
  label: {
    textTransform: "capitalize"
  },
  chips: {
    display: "flex",
    flexWrap: "wrap",
    marginTop: theme.spacing(1)
  },
  chip: {
    margin: 2
  }
}));
const SearchType = (props) => {
  const { className, defaultValue, name, values = [] } = props;
  const classes = useStyles();
  const { types, setTypes } = useSearch();
  useEffectOnce(() => {
    if (!types.length) {
      if (defaultValue && Array.isArray(defaultValue)) {
        setTypes(defaultValue);
      } else if (defaultValue) {
        setTypes([defaultValue]);
      }
    }
  });
  const handleChange = (e) => {
    const value = e.target.value;
    setTypes(value);
  };
  return /* @__PURE__ */ React.createElement(
    FormControl,
    {
      className,
      variant: "filled",
      fullWidth: true,
      "data-testid": "search-typefilter-next"
    },
    /* @__PURE__ */ React.createElement(InputLabel, { className: classes.label, margin: "dense" }, name),
    /* @__PURE__ */ React.createElement(
      Select,
      {
        multiple: true,
        variant: "outlined",
        value: types,
        onChange: handleChange,
        placeholder: "All Results",
        renderValue: (selected) => /* @__PURE__ */ React.createElement("div", { className: classes.chips }, selected.map((value) => /* @__PURE__ */ React.createElement(
          Chip,
          {
            key: value,
            label: value,
            className: classes.chip,
            size: "small"
          }
        )))
      },
      values.map((value) => /* @__PURE__ */ React.createElement(MenuItem, { key: value, value }, /* @__PURE__ */ React.createElement(Checkbox, { checked: types.indexOf(value) > -1 }), /* @__PURE__ */ React.createElement(ListItemText, { primary: value })))
    )
  );
};
SearchType.Accordion = (props) => {
  return /* @__PURE__ */ React.createElement(SearchTypeAccordion, { ...props });
};
SearchType.Tabs = (props) => {
  return /* @__PURE__ */ React.createElement(SearchTypeTabs, { ...props });
};

const SidebarSearch = (props) => {
  const searchRoute = useRouteRef(rootRouteRef);
  const { focusContent } = useContent();
  const navigate = useNavigate();
  const handleSearch = useCallback(
    (query) => {
      const queryString = qs.stringify({ query }, { addQueryPrefix: true });
      focusContent();
      navigate(`${searchRoute()}${queryString}`);
    },
    [focusContent, navigate, searchRoute]
  );
  return /* @__PURE__ */ React.createElement(
    SidebarSearchField,
    {
      icon: props.icon,
      onSearch: handleSearch,
      to: "/search"
    }
  );
};

export { HomePageSearchBar as H, SearchPage as S, SearchModalProvider as a, SearchModal as b, SearchType as c, SidebarSearch as d, SearchPage$1 as e, SidebarSearchModal as f, rootRouteRef as r, searchPlugin as s, useSearchModal as u };
//# sourceMappingURL=index-5d2cd78f.esm.js.map
