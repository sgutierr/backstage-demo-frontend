import { scmIntegrationsApiRef, scmAuthApiRef } from '@backstage/integration-react';
import { scaffolderApiRef, useTemplateSecrets, createScaffolderFieldExtension, useTaskEventStream } from '@backstage/plugin-scaffolder-react';
import { parseEntityRef, stringifyEntityRef, KubernetesValidatorFunctions, RELATION_OWNED_BY, makeValidator } from '@backstage/catalog-model';
import { ResponseError } from '@backstage/errors';
import qs from 'qs';
import ObservableImpl from 'zen-observable';
import { CATALOG_FILTER_EXISTS } from '@backstage/catalog-client';
import { useApi, identityApiRef, createExternalRouteRef, createRouteRef, createSubRouteRef, createPlugin, createApiFactory, discoveryApiRef, fetchApiRef, createRoutableExtension, useApp, useRouteRef, useRouteRefParams } from '@backstage/core-plugin-api';
import { catalogApiRef, humanizeEntityRef, entityRouteRef } from '@backstage/plugin-catalog-react';
import { TextField, FormControl as FormControl$1, Box, makeStyles, Grid, Typography, StepButton, Paper, Button, CircularProgress } from '@material-ui/core';
import FormControl from '@material-ui/core/FormControl';
import Autocomplete from '@material-ui/lab/Autocomplete';
import React, { useCallback, useEffect, useState, useMemo, useRef, memo } from 'react';
import useAsync from 'react-use/lib/useAsync';
import { z } from 'zod';
import zodToJsonSchema from 'zod-to-json-schema';
import FormHelperText from '@material-ui/core/FormHelperText';
import Input from '@material-ui/core/Input';
import InputLabel from '@material-ui/core/InputLabel';
import { Select, Progress, DismissableBanner, Link, Page, Header, Content, ErrorPage, LogViewer } from '@backstage/core-components';
import useDebounce from 'react-use/lib/useDebounce';
import useEffectOnce from 'react-use/lib/useEffectOnce';
import { Autocomplete as Autocomplete$1 } from '@material-ui/lab';
import Grid$1 from '@material-ui/core/Grid';
import Step from '@material-ui/core/Step';
import StepLabel from '@material-ui/core/StepLabel';
import Stepper from '@material-ui/core/Stepper';
import { makeStyles as makeStyles$1, createStyles } from '@material-ui/core/styles';
import Typography$1 from '@material-ui/core/Typography';
import Cancel from '@material-ui/icons/Cancel';
import Check from '@material-ui/icons/Check';
import FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';
import classNames from 'classnames';
import { DateTime, Interval } from 'luxon';
import { useNavigate } from 'react-router-dom';
import useInterval from 'react-use/lib/useInterval';
import LanguageIcon from '@material-ui/icons/Language';

class ScaffolderClient {
  constructor(options) {
    var _a, _b;
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = (_a = options.fetchApi) != null ? _a : { fetch };
    this.scmIntegrationsApi = options.scmIntegrationsApi;
    this.useLongPollingLogs = (_b = options.useLongPollingLogs) != null ? _b : false;
    this.identityApi = options.identityApi;
  }
  async listTasks(options) {
    if (!this.identityApi) {
      throw new Error(
        "IdentityApi is not available in the ScaffolderClient, please pass through the IdentityApi to the ScaffolderClient constructor in order to use the listTasks method"
      );
    }
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const { userEntityRef } = await this.identityApi.getBackstageIdentity();
    const query = qs.stringify(
      options.filterByOwnership === "owned" ? { createdBy: userEntityRef } : {}
    );
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/tasks?${query}`);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async getIntegrationsList(options) {
    const integrations = [
      ...this.scmIntegrationsApi.azure.list(),
      ...this.scmIntegrationsApi.bitbucket.list().filter(
        (item) => !this.scmIntegrationsApi.bitbucketCloud.byHost(item.config.host) && !this.scmIntegrationsApi.bitbucketServer.byHost(item.config.host)
      ),
      ...this.scmIntegrationsApi.bitbucketCloud.list(),
      ...this.scmIntegrationsApi.bitbucketServer.list(),
      ...this.scmIntegrationsApi.gerrit.list(),
      ...this.scmIntegrationsApi.github.list(),
      ...this.scmIntegrationsApi.gitlab.list()
    ].map((c) => ({ type: c.type, title: c.title, host: c.config.host })).filter((c) => options.allowedHosts.includes(c.host));
    return {
      integrations
    };
  }
  async getTemplateParameterSchema(templateRef) {
    const { namespace, kind, name } = parseEntityRef(templateRef, {
      defaultKind: "template"
    });
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const templatePath = [namespace, kind, name].map((s) => encodeURIComponent(s)).join("/");
    const url = `${baseUrl}/v2/templates/${templatePath}/parameter-schema`;
    const response = await this.fetchApi.fetch(url);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    const schema = await response.json();
    return schema;
  }
  async scaffold(options) {
    const { templateRef, values, secrets = {} } = options;
    const url = `${await this.discoveryApi.getBaseUrl("scaffolder")}/v2/tasks`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        templateRef,
        values: { ...values },
        secrets
      })
    });
    if (response.status !== 201) {
      const status = `${response.status} ${response.statusText}`;
      const body = await response.text();
      throw new Error(`Backend request failed, ${status} ${body.trim()}`);
    }
    const { id } = await response.json();
    return { taskId: id };
  }
  async getTask(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}`;
    const response = await this.fetchApi.fetch(url);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  streamLogs(options) {
    if (this.useLongPollingLogs) {
      return this.streamLogsPolling(options);
    }
    return this.streamLogsEventStream(options);
  }
  async dryRun(options) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/dry-run`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        template: options.template,
        values: options.values,
        secrets: options.secrets,
        directoryContents: options.directoryContents
      })
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return response.json();
  }
  streamLogsEventStream({
    taskId,
    after
  }) {
    return new ObservableImpl((subscriber) => {
      const params = new URLSearchParams();
      if (after !== void 0) {
        params.set("after", String(Number(after)));
      }
      this.discoveryApi.getBaseUrl("scaffolder").then(
        (baseUrl) => {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/eventstream`;
          const processEvent = (event) => {
            if (event.data) {
              try {
                subscriber.next(JSON.parse(event.data));
              } catch (ex) {
                subscriber.error(ex);
              }
            }
          };
          const eventSource = new EventSource(url, { withCredentials: true });
          eventSource.addEventListener("log", processEvent);
          eventSource.addEventListener("cancelled", processEvent);
          eventSource.addEventListener("completion", (event) => {
            processEvent(event);
            eventSource.close();
            subscriber.complete();
          });
          eventSource.addEventListener("error", (event) => {
            subscriber.error(event);
          });
        },
        (error) => {
          subscriber.error(error);
        }
      );
    });
  }
  streamLogsPolling({
    taskId,
    after: inputAfter
  }) {
    let after = inputAfter;
    return new ObservableImpl((subscriber) => {
      this.discoveryApi.getBaseUrl("scaffolder").then(async (baseUrl) => {
        while (!subscriber.closed) {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/events?${qs.stringify({ after })}`;
          const response = await this.fetchApi.fetch(url);
          if (!response.ok) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
            continue;
          }
          const logs = await response.json();
          for (const event of logs) {
            after = Number(event.id);
            subscriber.next(event);
            if (event.type === "completion") {
              subscriber.complete();
              return;
            }
          }
        }
      });
    });
  }
  async listActions() {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/actions`);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async cancelTask(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}/cancel`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST"
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
}

function makeFieldSchemaFromZod(returnSchema, uiOptionsSchema) {
  return {
    schema: {
      returnValue: zodToJsonSchema(returnSchema),
      uiOptions: uiOptionsSchema ? zodToJsonSchema(uiOptionsSchema) : void 0
    },
    type: null,
    uiOptionsType: null
  };
}

const entityQueryFilterExpressionSchema = z.record(
  z.string().or(z.object({ exists: z.boolean().optional() })).or(z.array(z.string()))
);
const EntityPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    /**
     * @deprecated Use `catalogFilter` instead.
     */
    allowedKinds: z.array(z.string()).optional().describe(
      "DEPRECATED: Use `catalogFilter` instead. List of kinds of entities to derive options from"
    ),
    defaultKind: z.string().optional().describe(
      "The default entity kind. Options of this kind will not be prefixed."
    ),
    allowArbitraryValues: z.boolean().optional().describe("Whether to allow arbitrary user input. Defaults to true"),
    defaultNamespace: z.union([z.string(), z.literal(false)]).optional().describe(
      "The default namespace. Options with this namespace will not be prefixed."
    ),
    catalogFilter: z.array(entityQueryFilterExpressionSchema).or(entityQueryFilterExpressionSchema).optional().describe("List of key-value filter expression for entities")
  })
);
const EntityPickerSchema = EntityPickerFieldSchema.schema;

const EntityPicker = (props) => {
  var _a, _b, _c, _d, _e;
  const {
    onChange,
    schema: { title = "Entity", description = "An entity from the catalog" },
    required,
    uiSchema,
    rawErrors,
    formData,
    idSchema
  } = props;
  const catalogFilter = buildCatalogFilter(uiSchema);
  const defaultKind = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.defaultKind;
  const defaultNamespace = ((_b = uiSchema["ui:options"]) == null ? void 0 : _b.defaultNamespace) || void 0;
  const catalogApi = useApi(catalogApiRef);
  const { value: entities, loading } = useAsync(async () => {
    const { items } = await catalogApi.getEntities(
      catalogFilter ? { filter: catalogFilter } : void 0
    );
    return items;
  });
  const allowArbitraryValues = (_d = (_c = uiSchema["ui:options"]) == null ? void 0 : _c.allowArbitraryValues) != null ? _d : true;
  const getLabel = useCallback(
    (ref) => {
      try {
        return humanizeEntityRef(
          parseEntityRef(ref, { defaultKind, defaultNamespace }),
          {
            defaultKind,
            defaultNamespace
          }
        );
      } catch (err) {
        return ref;
      }
    },
    [defaultKind, defaultNamespace]
  );
  const onSelect = useCallback(
    (_, ref, reason) => {
      if (typeof ref !== "string") {
        onChange(ref ? stringifyEntityRef(ref) : void 0);
      } else {
        if (reason === "blur" || reason === "create-option") {
          let entityRef = ref;
          try {
            entityRef = stringifyEntityRef(
              parseEntityRef(ref, {
                defaultKind,
                defaultNamespace
              })
            );
          } catch (err) {
          }
          if (formData !== ref || allowArbitraryValues) {
            onChange(entityRef);
          }
        }
      }
    },
    [onChange, formData, defaultKind, defaultNamespace, allowArbitraryValues]
  );
  useEffect(() => {
    if ((entities == null ? void 0 : entities.length) === 1) {
      onChange(stringifyEntityRef(entities[0]));
    }
  }, [entities, onChange]);
  return /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !formData
    },
    /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        disabled: (entities == null ? void 0 : entities.length) === 1,
        id: idSchema == null ? void 0 : idSchema.$id,
        value: (
          // Since free solo can be enabled, attempt to parse as a full entity ref first, then fall
          //  back to the given value.
          (_e = entities == null ? void 0 : entities.find((e) => stringifyEntityRef(e) === formData)) != null ? _e : allowArbitraryValues && formData ? getLabel(formData) : ""
        ),
        loading,
        onChange: onSelect,
        options: entities || [],
        getOptionLabel: (option) => (
          // option can be a string due to freeSolo.
          typeof option === "string" ? option : humanizeEntityRef(option, { defaultKind, defaultNamespace })
        ),
        autoSelect: true,
        freeSolo: allowArbitraryValues,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required,
            InputProps: params.InputProps
          }
        )
      }
    )
  );
};
function convertOpsValues(value) {
  if (typeof value === "object" && value.exists) {
    return CATALOG_FILTER_EXISTS;
  }
  return value == null ? void 0 : value.toString();
}
function convertSchemaFiltersToQuery(schemaFilters) {
  const query = {};
  for (const [key, value] of Object.entries(schemaFilters)) {
    if (Array.isArray(value)) {
      query[key] = value;
    } else {
      query[key] = convertOpsValues(value);
    }
  }
  return query;
}
function buildCatalogFilter(uiSchema) {
  var _a, _b;
  const allowedKinds = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.allowedKinds;
  const catalogFilter = ((_b = uiSchema["ui:options"]) == null ? void 0 : _b.catalogFilter) || allowedKinds && { kind: allowedKinds };
  if (!catalogFilter) {
    return void 0;
  }
  if (Array.isArray(catalogFilter)) {
    return catalogFilter.map(convertSchemaFiltersToQuery);
  }
  return convertSchemaFiltersToQuery(catalogFilter);
}

const entityNamePickerValidation = (value, validation) => {
  if (!KubernetesValidatorFunctions.isValidObjectName(value)) {
    validation.addError(
      "Must start and end with an alphanumeric character, and contain only alphanumeric characters, hyphens, underscores, and periods. Maximum length is 63 characters."
    );
  }
};

const EntityNamePickerFieldSchema = makeFieldSchemaFromZod(z.string());
const EntityNamePickerSchema = EntityNamePickerFieldSchema.schema;

const EntityNamePicker = (props) => {
  const {
    onChange,
    required,
    schema: { title = "Name", description = "Unique name of the component" },
    rawErrors,
    formData,
    uiSchema: { "ui:autofocus": autoFocus },
    idSchema,
    placeholder
  } = props;
  return /* @__PURE__ */ React.createElement(
    TextField,
    {
      id: idSchema == null ? void 0 : idSchema.$id,
      label: title,
      placeholder,
      helperText: description,
      required,
      value: formData != null ? formData : "",
      onChange: ({ target: { value } }) => onChange(value),
      margin: "normal",
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !formData,
      inputProps: { autoFocus }
    }
  );
};

const OwnerPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    /**
     * @deprecated Use `catalogFilter` instead.
     */
    allowedKinds: z.array(z.string()).default(["Group", "User"]).optional().describe(
      "DEPRECATED: Use `catalogFilter` instead. List of kinds of entities to derive options from. Defaults to Group and User"
    ),
    allowArbitraryValues: z.boolean().optional().describe("Whether to allow arbitrary user input. Defaults to true"),
    defaultNamespace: z.union([z.string(), z.literal(false)]).optional().describe(
      "The default namespace. Options with this namespace will not be prefixed."
    ),
    catalogFilter: z.array(entityQueryFilterExpressionSchema).or(entityQueryFilterExpressionSchema).optional().describe("List of key-value filter expression for entities")
  })
);
const OwnerPickerSchema = OwnerPickerFieldSchema.schema;

const OwnerPicker = (props) => {
  var _a, _b, _c, _d, _e;
  const {
    schema: { title = "Owner", description = "The owner of the component" },
    uiSchema,
    ...restProps
  } = props;
  const defaultNamespace = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.defaultNamespace;
  const allowedKinds = (_b = uiSchema["ui:options"]) == null ? void 0 : _b.allowedKinds;
  const catalogFilter = ((_c = uiSchema["ui:options"]) == null ? void 0 : _c.catalogFilter) || {
    kind: allowedKinds || ["Group", "User"]
  };
  const ownerUiSchema = {
    ...uiSchema,
    "ui:options": {
      catalogFilter,
      defaultKind: "Group",
      allowArbitraryValues: (_e = (_d = uiSchema["ui:options"]) == null ? void 0 : _d.allowArbitraryValues) != null ? _e : true,
      ...defaultNamespace !== void 0 ? { defaultNamespace } : {}
    }
  };
  return /* @__PURE__ */ React.createElement(
    EntityPicker,
    {
      ...restProps,
      schema: { title, description },
      uiSchema: ownerUiSchema
    }
  );
};

const RepoUrlPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    allowedHosts: z.array(z.string()).optional().describe("List of allowed SCM platform hosts"),
    allowedOrganizations: z.array(z.string()).optional().describe("List of allowed organizations in the given SCM platform"),
    allowedOwners: z.array(z.string()).optional().describe("List of allowed owners in the given SCM platform"),
    allowedProjects: z.array(z.string()).optional().describe("List of allowed projects in the given SCM platform"),
    allowedRepos: z.array(z.string()).optional().describe("List of allowed repos in the given SCM platform"),
    requestUserCredentials: z.object({
      secretsKey: z.string().describe(
        "Key used within the template secrets context to store the credential"
      ),
      additionalScopes: z.object({
        gerrit: z.array(z.string()).optional().describe("Additional Gerrit scopes to request"),
        github: z.array(z.string()).optional().describe("Additional GitHub scopes to request"),
        gitlab: z.array(z.string()).optional().describe("Additional GitLab scopes to request"),
        bitbucket: z.array(z.string()).optional().describe("Additional BitBucket scopes to request"),
        azure: z.array(z.string()).optional().describe("Additional Azure scopes to request")
      }).optional().describe("Additional permission scopes to request")
    }).optional().describe(
      "If defined will request user credentials to auth against the given SCM platform"
    )
  })
);
const RepoUrlPickerSchema = RepoUrlPickerFieldSchema.schema;

const repoPickerValidation = (value, validation, context) => {
  var _a, _b;
  try {
    const { host, searchParams } = new URL(`https://${value}`);
    const integrationApi = context.apiHolder.get(scmIntegrationsApiRef);
    if (!host) {
      validation.addError(
        "Incomplete repository location provided, host not provided"
      );
    } else {
      if (((_a = integrationApi == null ? void 0 : integrationApi.byHost(host)) == null ? void 0 : _a.type) === "bitbucket") {
        if (host === "bitbucket.org" && !searchParams.get("workspace")) {
          validation.addError(
            "Incomplete repository location provided, workspace not provided"
          );
        }
        if (!searchParams.get("project")) {
          validation.addError(
            "Incomplete repository location provided, project not provided"
          );
        }
      } else if (((_b = integrationApi == null ? void 0 : integrationApi.byHost(host)) == null ? void 0 : _b.type) !== "gerrit") {
        if (!searchParams.get("owner")) {
          validation.addError(
            "Incomplete repository location provided, owner not provided"
          );
        }
      }
      if (!searchParams.get("repo")) {
        validation.addError(
          "Incomplete repository location provided, repo not provided"
        );
      }
    }
  } catch {
    validation.addError("Unable to parse the Repository URL");
  }
};

const GithubRepoPicker = (props) => {
  const { allowedOwners = [], rawErrors, state, onChange } = props;
  const ownerItems = allowedOwners ? allowedOwners.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const { owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Owner Available",
        onChange: (s) => onChange({ owner: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOwners.length === 1,
        selected: owner,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Owner"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "ownerInput",
        onChange: (e) => onChange({ owner: e.target.value }),
        value: owner
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The organization, user or project that this repo will belong to")
  ));
};

const GitlabRepoPicker = (props) => {
  const { allowedOwners = [], state, onChange, rawErrors } = props;
  const ownerItems = allowedOwners ? allowedOwners.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const { owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Owner Available",
        onChange: (selected) => onChange({
          owner: String(Array.isArray(selected) ? selected[0] : selected)
        }),
        disabled: allowedOwners.length === 1,
        selected: owner,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Owner"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "ownerInput",
        onChange: (e) => onChange({ owner: e.target.value }),
        value: owner
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "GitLab namespace where this repository will belong to. It can be the name of organization, group, subgroup, user, or the project.")
  ));
};

const AzureRepoPicker = (props) => {
  const {
    allowedOrganizations = [],
    allowedOwners = [],
    rawErrors,
    state,
    onChange
  } = props;
  const organizationItems = allowedOrganizations ? allowedOrganizations.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const ownerItems = allowedOwners ? allowedOwners.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const { organization, owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !organization
    },
    (allowedOrganizations == null ? void 0 : allowedOrganizations.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Organization",
        onChange: (s) => onChange({ organization: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOrganizations.length === 1,
        selected: organization,
        items: organizationItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "orgInput" }, "Organization"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "orgInput",
        onChange: (e) => onChange({ organization: e.target.value }),
        value: organization
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Organization that this repo will belong to")
  ), /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Owner",
        onChange: (s) => onChange({ owner: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOwners.length === 1,
        selected: owner,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Project"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "ownerInput",
        onChange: (e) => onChange({ owner: e.target.value }),
        value: owner
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Project that this repo will belong to")
  ));
};

const BitbucketRepoPicker = (props) => {
  const {
    allowedOwners = [],
    allowedProjects = [],
    onChange,
    rawErrors,
    state
  } = props;
  const { host, workspace, project } = state;
  const ownerItems = allowedOwners ? allowedOwners == null ? void 0 : allowedOwners.map((i) => ({ label: i, value: i })) : [];
  const projectItems = allowedProjects ? allowedProjects == null ? void 0 : allowedProjects.map((i) => ({ label: i, value: i })) : [];
  useEffect(() => {
    if (host === "bitbucket.org" && allowedOwners.length) {
      onChange({ workspace: allowedOwners[0] });
    }
  }, [allowedOwners, host, onChange]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, host === "bitbucket.org" && /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !workspace
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Allowed Workspaces",
        onChange: (s) => onChange({ workspace: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOwners.length === 1,
        selected: workspace,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "workspaceInput" }, "Workspace"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "workspaceInput",
        onChange: (e) => onChange({ workspace: e.target.value }),
        value: workspace
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Workspace that this repo will belong to")
  ), /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !project
    },
    (allowedProjects == null ? void 0 : allowedProjects.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Allowed Projects",
        onChange: (s) => onChange({ project: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedProjects.length === 1,
        selected: project,
        items: projectItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "projectInput" }, "Project"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "projectInput",
        onChange: (e) => onChange({ project: e.target.value }),
        value: project
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Project that this repo will belong to")
  ));
};

const GerritRepoPicker = (props) => {
  const { onChange, rawErrors, state } = props;
  const { workspace, owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(FormControl, { margin: "normal", error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !workspace }, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Owner"), /* @__PURE__ */ React.createElement(
    Input,
    {
      id: "ownerInput",
      onChange: (e) => onChange({ owner: e.target.value }),
      value: owner
    }
  ), /* @__PURE__ */ React.createElement(FormHelperText, null, "The owner of the project (optional)")), /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !workspace
    },
    /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "parentInput" }, "Parent"),
    /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "parentInput",
        onChange: (e) => onChange({ workspace: e.target.value }),
        value: workspace
      }
    ),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The project parent that the repo will belong to")
  ));
};

const RepoUrlPickerHost = (props) => {
  const { host, hosts, onChange, rawErrors } = props;
  const scaffolderApi = useApi(scaffolderApiRef);
  const { value: { integrations } = { integrations: [] }, loading } = useAsync(
    async () => {
      return await scaffolderApi.getIntegrationsList({
        allowedHosts: hosts != null ? hosts : []
      });
    }
  );
  useEffect(() => {
    if (!host) {
      if (hosts == null ? void 0 : hosts.length) {
        onChange(hosts[0]);
      } else if (integrations == null ? void 0 : integrations.length) {
        onChange(integrations[0].host);
      }
    }
  }, [hosts, host, onChange, integrations]);
  const hostsOptions = integrations ? integrations.filter((i) => (hosts == null ? void 0 : hosts.length) ? hosts == null ? void 0 : hosts.includes(i.host) : true).map((i) => ({ label: i.title, value: i.host })) : [{ label: "Loading...", value: "loading" }];
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !host
    },
    /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        disabled: (hosts == null ? void 0 : hosts.length) === 1,
        label: "Host",
        onChange: (s) => onChange(String(Array.isArray(s) ? s[0] : s)),
        selected: host,
        items: hostsOptions,
        "data-testid": "host-select"
      }
    ),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The host where the repository will be created")
  ));
};

const RepoUrlPickerRepoName = (props) => {
  const { repoName, allowedRepos, onChange, rawErrors } = props;
  useEffect(() => {
    if (!repoName) {
      if (allowedRepos == null ? void 0 : allowedRepos.length) {
        onChange(allowedRepos[0]);
      }
    }
  }, [allowedRepos, repoName, onChange]);
  const repoItems = allowedRepos ? allowedRepos.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !repoName
    },
    (allowedRepos == null ? void 0 : allowedRepos.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Repositories Available",
        onChange: (selected) => String(Array.isArray(selected) ? selected[0] : selected),
        disabled: allowedRepos.length === 1,
        selected: repoName,
        items: repoItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "repoNameInput" }, "Repository"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "repoNameInput",
        onChange: (e) => onChange(String(e.target.value)),
        value: repoName
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The name of the repository")
  ));
};

function serializeRepoPickerUrl(data) {
  if (!data.host) {
    return void 0;
  }
  const params = new URLSearchParams();
  if (data.owner) {
    params.set("owner", data.owner);
  }
  if (data.repoName) {
    params.set("repo", data.repoName);
  }
  if (data.organization) {
    params.set("organization", data.organization);
  }
  if (data.workspace) {
    params.set("workspace", data.workspace);
  }
  if (data.project) {
    params.set("project", data.project);
  }
  return `${data.host}?${params.toString()}`;
}
function parseRepoPickerUrl(url) {
  let host = "";
  let owner = "";
  let repoName = "";
  let organization = "";
  let workspace = "";
  let project = "";
  try {
    if (url) {
      const parsed = new URL(`https://${url}`);
      host = parsed.host;
      owner = parsed.searchParams.get("owner") || "";
      repoName = parsed.searchParams.get("repo") || "";
      organization = parsed.searchParams.get("organization") || "";
      workspace = parsed.searchParams.get("workspace") || "";
      project = parsed.searchParams.get("project") || "";
    }
  } catch {
  }
  return { host, owner, repoName, organization, workspace, project };
}

const RepoUrlPicker = (props) => {
  var _a, _b;
  const { uiSchema, onChange, rawErrors, formData } = props;
  const [state, setState] = useState(
    parseRepoPickerUrl(formData)
  );
  const integrationApi = useApi(scmIntegrationsApiRef);
  const scmAuthApi = useApi(scmAuthApiRef);
  const { setSecrets } = useTemplateSecrets();
  const allowedHosts = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedHosts) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedOrganizations = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedOrganizations) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedOwners = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedOwners) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedProjects = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedProjects) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedRepos = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedRepos) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const { owner, organization, project, repoName } = state;
  useEffect(() => {
    onChange(serializeRepoPickerUrl(state));
  }, [state, onChange]);
  useEffect(() => {
    if (allowedOrganizations.length > 0 && !organization) {
      setState((prevState) => ({
        ...prevState,
        organization: allowedOrganizations[0]
      }));
    }
  }, [setState, allowedOrganizations, organization]);
  useEffect(() => {
    if (allowedOwners.length > 0 && !owner) {
      setState((prevState) => ({
        ...prevState,
        owner: allowedOwners[0]
      }));
    }
  }, [setState, allowedOwners, owner]);
  useEffect(() => {
    if (allowedProjects.length > 0 && !project) {
      setState((prevState) => ({
        ...prevState,
        project: allowedProjects[0]
      }));
    }
  }, [setState, allowedProjects, project]);
  useEffect(() => {
    if (allowedRepos.length > 0 && !repoName) {
      setState((prevState) => ({ ...prevState, repoName: allowedRepos[0] }));
    }
  }, [setState, allowedRepos, repoName]);
  const updateLocalState = useCallback(
    (newState) => {
      setState((prevState) => ({ ...prevState, ...newState }));
    },
    [setState]
  );
  useDebounce(
    async () => {
      var _a2;
      const { requestUserCredentials } = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) != null ? _a2 : {};
      const workspace = state.owner ? state.owner : state.project;
      if (!requestUserCredentials || !(state.host && workspace && state.repoName)) {
        return;
      }
      const [encodedHost, encodedRepoName] = [state.host, state.repoName].map(
        encodeURIComponent
      );
      const { token } = await scmAuthApi.getCredentials({
        url: `https://${encodedHost}/${workspace}/${encodedRepoName}`,
        additionalScope: {
          repoWrite: true,
          customScopes: requestUserCredentials.additionalScopes
        }
      });
      setSecrets({ [requestUserCredentials.secretsKey]: token });
    },
    500,
    [state, uiSchema]
  );
  const hostType = (_b = state.host && ((_a = integrationApi.byHost(state.host)) == null ? void 0 : _a.type)) != null ? _b : null;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    RepoUrlPickerHost,
    {
      host: state.host,
      hosts: allowedHosts,
      onChange: (host) => setState((prevState) => ({ ...prevState, host })),
      rawErrors
    }
  ), hostType === "github" && /* @__PURE__ */ React.createElement(
    GithubRepoPicker,
    {
      allowedOwners,
      onChange: updateLocalState,
      rawErrors,
      state
    }
  ), hostType === "gitlab" && /* @__PURE__ */ React.createElement(
    GitlabRepoPicker,
    {
      allowedOwners,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "bitbucket" && /* @__PURE__ */ React.createElement(
    BitbucketRepoPicker,
    {
      allowedOwners,
      allowedProjects,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "azure" && /* @__PURE__ */ React.createElement(
    AzureRepoPicker,
    {
      allowedOrganizations,
      allowedOwners,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "gerrit" && /* @__PURE__ */ React.createElement(
    GerritRepoPicker,
    {
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), /* @__PURE__ */ React.createElement(
    RepoUrlPickerRepoName,
    {
      repoName: state.repoName,
      allowedRepos,
      onChange: (repo) => setState((prevState) => ({ ...prevState, repoName: repo })),
      rawErrors
    }
  ));
};

const OwnedEntityPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    allowedKinds: z.array(z.string()).optional().describe("List of kinds of entities to derive options from"),
    defaultKind: z.string().optional().describe(
      "The default entity kind. Options of this kind will not be prefixed."
    ),
    allowArbitraryValues: z.boolean().optional().describe("Whether to allow arbitrary user input. Defaults to true"),
    defaultNamespace: z.union([z.string(), z.literal(false)]).optional().describe(
      "The default namespace. Options with this namespace will not be prefixed."
    )
  })
);
const OwnedEntityPickerSchema = OwnedEntityPickerFieldSchema.schema;

const OwnedEntityPicker = (props) => {
  var _a;
  const {
    schema: { title = "Entity", description = "An entity from the catalog" },
    uiSchema,
    required
  } = props;
  const identityApi = useApi(identityApiRef);
  const { loading, value: identityRefs } = useAsync(async () => {
    const identity = await identityApi.getBackstageIdentity();
    return identity.ownershipEntityRefs;
  });
  const allowedKinds = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.allowedKinds;
  if (loading)
    return /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        loading,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required,
            InputProps: params.InputProps
          }
        ),
        options: []
      }
    );
  return /* @__PURE__ */ React.createElement(
    EntityPicker,
    {
      ...props,
      schema: { title, description },
      allowedKinds,
      catalogFilter: allowedKinds ? {
        filter: {
          kind: allowedKinds,
          [`relations.${RELATION_OWNED_BY}`]: identityRefs || []
        }
      } : {
        filter: {
          [`relations.${RELATION_OWNED_BY}`]: identityRefs || []
        }
      }
    }
  );
};

const EntityTagsPickerFieldSchema = makeFieldSchemaFromZod(
  z.array(z.string()),
  z.object({
    kinds: z.array(z.string()).optional().describe("List of kinds of entities to derive tags from"),
    showCounts: z.boolean().optional().describe("Whether to show usage counts per tag"),
    helperText: z.string().optional().describe("Helper text to display")
  })
);
const EntityTagsPickerSchema = EntityTagsPickerFieldSchema.schema;

const EntityTagsPicker = (props) => {
  var _a, _b, _c;
  const { formData, onChange, uiSchema } = props;
  const catalogApi = useApi(catalogApiRef);
  const [tagOptions, setTagOptions] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [inputError, setInputError] = useState(false);
  const tagValidator = makeValidator().isValidTag;
  const kinds = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.kinds;
  const showCounts = (_b = uiSchema["ui:options"]) == null ? void 0 : _b.showCounts;
  const helperText = (_c = uiSchema["ui:options"]) == null ? void 0 : _c.helperText;
  const { loading, value: existingTags } = useAsync(async () => {
    const facet = "metadata.tags";
    const tagsRequest = { facets: [facet] };
    if (kinds) {
      tagsRequest.filter = { kind: kinds };
    }
    const { facets } = await catalogApi.getEntityFacets(tagsRequest);
    const tagFacets = Object.fromEntries(
      facets[facet].map(({ value, count }) => [value, count])
    );
    setTagOptions(
      Object.keys(tagFacets).sort(
        (a, b) => showCounts ? tagFacets[b] - tagFacets[a] : a.localeCompare(b)
      )
    );
    return tagFacets;
  });
  const setTags = (_, values) => {
    let hasError = false;
    let addDuplicate = false;
    const currentTags = formData || [];
    if ((values == null ? void 0 : values.length) && currentTags.length < values.length) {
      const newTag = values[values.length - 1] = values[values.length - 1].toLocaleLowerCase("en-US").trim();
      hasError = !tagValidator(newTag);
      addDuplicate = currentTags.indexOf(newTag) !== -1;
    }
    setInputError(hasError);
    setInputValue(!hasError ? "" : inputValue);
    if (!hasError && !addDuplicate) {
      onChange(values || []);
    }
  };
  useEffectOnce(() => onChange(formData || []));
  return /* @__PURE__ */ React.createElement(FormControl$1, { margin: "normal" }, /* @__PURE__ */ React.createElement(
    Autocomplete$1,
    {
      multiple: true,
      freeSolo: true,
      filterSelectedOptions: true,
      onChange: setTags,
      value: formData || [],
      inputValue,
      loading,
      options: tagOptions,
      ChipProps: { size: "small" },
      renderOption: (option) => showCounts ? `${option} (${existingTags == null ? void 0 : existingTags[option]})` : option,
      renderInput: (params) => /* @__PURE__ */ React.createElement(
        TextField,
        {
          ...params,
          label: "Tags",
          onChange: (e) => setInputValue(e.target.value),
          error: inputError,
          helperText: helperText != null ? helperText : "Add any relevant tags, hit 'Enter' to add new tags. Valid format: [a-z0-9+#] separated by [-], at most 63 characters"
        }
      )
    }
  ));
};

const registerComponentRouteRef = createExternalRouteRef({
  id: "register-component",
  optional: true
});
const viewTechDocRouteRef = createExternalRouteRef({
  id: "view-techdoc",
  optional: true,
  params: ["namespace", "kind", "name"]
});
const rootRouteRef = createRouteRef({
  id: "scaffolder"
});
const legacySelectedTemplateRouteRef = createSubRouteRef({
  id: "scaffolder/legacy/selected-template",
  parent: rootRouteRef,
  path: "/templates/:templateName"
});
const selectedTemplateRouteRef = createSubRouteRef({
  id: "scaffolder/selected-template",
  parent: rootRouteRef,
  path: "/templates/:namespace/:templateName"
});
const scaffolderTaskRouteRef = createSubRouteRef({
  id: "scaffolder/task",
  parent: rootRouteRef,
  path: "/tasks/:taskId"
});
const scaffolderListTaskRouteRef = createSubRouteRef({
  id: "scaffolder/list-tasks",
  parent: rootRouteRef,
  path: "/tasks"
});
const actionsRouteRef = createSubRouteRef({
  id: "scaffolder/actions",
  parent: rootRouteRef,
  path: "/actions"
});
const editRouteRef = createSubRouteRef({
  id: "scaffolder/edit",
  parent: rootRouteRef,
  path: "/edit"
});

const scaffolderPlugin = createPlugin({
  id: "scaffolder",
  apis: [
    createApiFactory({
      api: scaffolderApiRef,
      deps: {
        discoveryApi: discoveryApiRef,
        scmIntegrationsApi: scmIntegrationsApiRef,
        fetchApi: fetchApiRef,
        identityApi: identityApiRef
      },
      factory: ({ discoveryApi, scmIntegrationsApi, fetchApi, identityApi }) => new ScaffolderClient({
        discoveryApi,
        scmIntegrationsApi,
        fetchApi,
        identityApi
      })
    })
  ],
  routes: {
    root: rootRouteRef,
    selectedTemplate: selectedTemplateRouteRef,
    ongoingTask: scaffolderTaskRouteRef,
    actions: actionsRouteRef,
    listTasks: scaffolderListTaskRouteRef,
    edit: editRouteRef
  },
  externalRoutes: {
    registerComponent: registerComponentRouteRef,
    viewTechDoc: viewTechDocRouteRef
  }
});
const EntityPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: EntityPicker,
    name: "EntityPicker",
    schema: EntityPickerSchema
  })
);
const EntityNamePickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: EntityNamePicker,
    name: "EntityNamePicker",
    validation: entityNamePickerValidation,
    schema: EntityNamePickerSchema
  })
);
const RepoUrlPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: RepoUrlPicker,
    name: "RepoUrlPicker",
    validation: repoPickerValidation,
    schema: RepoUrlPickerSchema
  })
);
const OwnerPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: OwnerPicker,
    name: "OwnerPicker",
    schema: OwnerPickerSchema
  })
);
const ScaffolderPage = scaffolderPlugin.provide(
  createRoutableExtension({
    name: "ScaffolderPage",
    component: () => import('./Router-4536c02d.esm.js').then((m) => m.Router),
    mountPoint: rootRouteRef
  })
);
const OwnedEntityPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: OwnedEntityPicker,
    name: "OwnedEntityPicker",
    schema: OwnedEntityPickerSchema
  })
);
const EntityTagsPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: EntityTagsPicker,
    name: "EntityTagsPicker",
    schema: EntityTagsPickerSchema
  })
);
const NextScaffolderPage = scaffolderPlugin.provide(
  createRoutableExtension({
    name: "NextScaffolderPage",
    component: () => import('./index-9a46055b.esm.js').then((m) => m.Router),
    mountPoint: rootRouteRef
  })
);

const TaskErrors = ({ error }) => {
  const id = useRef("");
  useEffect(() => {
    id.current = String(Math.random());
  }, [error]);
  return error ? /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(
    DismissableBanner,
    {
      id: id.current,
      variant: "warning",
      message: error.message
    }
  )) : null;
};

const useStyles$1 = makeStyles({
  svgIcon: {
    display: "inline-block",
    "& svg": {
      display: "inline-block",
      fontSize: "inherit",
      verticalAlign: "baseline"
    }
  }
});
const IconLink = (props) => {
  const { href, text, Icon, ...linkProps } = props;
  const classes = useStyles$1();
  return /* @__PURE__ */ React.createElement(Grid, { container: true, direction: "row", spacing: 1 }, /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(Typography, { component: "div", className: classes.svgIcon }, Icon ? /* @__PURE__ */ React.createElement(Icon, null) : /* @__PURE__ */ React.createElement(LanguageIcon, null))), /* @__PURE__ */ React.createElement(Grid, { item: true }, /* @__PURE__ */ React.createElement(Link, { to: href, ...linkProps }, text || href)));
};

const TaskPageLinks = ({ output }) => {
  const { links = [] } = output;
  const app = useApp();
  const entityRoute = useRouteRef(entityRouteRef);
  const iconResolver = (key) => {
    var _a;
    return key ? (_a = app.getSystemIcon(key)) != null ? _a : LanguageIcon : LanguageIcon;
  };
  return /* @__PURE__ */ React.createElement(Box, { px: 3, pb: 3 }, links.filter(({ url, entityRef }) => url || entityRef).map(({ url, entityRef, title, icon }) => {
    if (entityRef) {
      const entityName = parseEntityRef(entityRef, {
        defaultKind: "<unknown>",
        defaultNamespace: "<unknown>"
      });
      const target = entityRoute(entityName);
      return { title, icon, url: target };
    }
    return { title, icon, url };
  }).map(({ url, title, icon }, i) => /* @__PURE__ */ React.createElement(
    IconLink,
    {
      key: `output-link-${i}`,
      href: url,
      text: title != null ? title : url,
      Icon: iconResolver(icon),
      target: "_blank"
    }
  )));
};

const humanizeDuration = require("humanize-duration");
const useStyles = makeStyles$1(
  (theme) => createStyles({
    root: {
      width: "100%"
    },
    button: {
      marginBottom: theme.spacing(2),
      marginLeft: theme.spacing(2)
    },
    actionsContainer: {
      marginBottom: theme.spacing(2)
    },
    resetContainer: {
      padding: theme.spacing(3)
    },
    labelWrapper: {
      display: "flex",
      flex: 1,
      flexDirection: "row",
      justifyContent: "space-between"
    },
    stepWrapper: {
      width: "100%"
    }
  })
);
const StepTimeTicker = ({ step }) => {
  const [time, setTime] = useState("");
  useInterval(() => {
    if (!step.startedAt) {
      setTime("");
      return;
    }
    const end = step.endedAt ? DateTime.fromISO(step.endedAt) : DateTime.local();
    const startedAt = DateTime.fromISO(step.startedAt);
    const formatted = Interval.fromDateTimes(startedAt, end).toDuration().valueOf();
    setTime(humanizeDuration(formatted, { round: true }));
  }, 1e3);
  return /* @__PURE__ */ React.createElement(Typography$1, { variant: "caption" }, time);
};
const useStepIconStyles = makeStyles$1(
  (theme) => createStyles({
    root: {
      color: theme.palette.text.disabled,
      display: "flex",
      height: 22,
      alignItems: "center"
    },
    completed: {
      color: theme.palette.status.ok
    },
    error: {
      color: theme.palette.status.error
    }
  })
);
function TaskStepIconComponent(props) {
  const classes = useStepIconStyles();
  const { active, completed, error } = props;
  const getMiddle = () => {
    if (active) {
      return /* @__PURE__ */ React.createElement(CircularProgress, { size: "24px" });
    }
    if (completed) {
      return /* @__PURE__ */ React.createElement(Check, null);
    }
    if (error) {
      return /* @__PURE__ */ React.createElement(Cancel, null);
    }
    return /* @__PURE__ */ React.createElement(FiberManualRecordIcon, null);
  };
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      className: classNames(classes.root, {
        [classes.completed]: completed,
        [classes.error]: error
      })
    },
    getMiddle()
  );
}
const TaskStatusStepper = memo(
  (props) => {
    const { steps, currentStepId, onUserStepChange } = props;
    const classes = useStyles(props);
    return /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement(
      Stepper,
      {
        activeStep: steps.findIndex((s) => s.id === currentStepId),
        orientation: "vertical",
        nonLinear: true
      },
      steps.map((step, index) => {
        const isCancelled = step.status === "cancelled";
        const isActive = step.status === "processing";
        const isCompleted = step.status === "completed";
        const isFailed = step.status === "failed";
        const isSkipped = step.status === "skipped";
        return /* @__PURE__ */ React.createElement(Step, { key: String(index), expanded: true }, /* @__PURE__ */ React.createElement(StepButton, { onClick: () => onUserStepChange(step.id) }, /* @__PURE__ */ React.createElement(
          StepLabel,
          {
            StepIconProps: {
              completed: isCompleted,
              error: isFailed || isCancelled,
              active: isActive
            },
            StepIconComponent: TaskStepIconComponent,
            className: classes.stepWrapper
          },
          /* @__PURE__ */ React.createElement("div", { className: classes.labelWrapper }, /* @__PURE__ */ React.createElement(Typography$1, { variant: "subtitle2" }, step.name), isSkipped ? /* @__PURE__ */ React.createElement(Typography$1, { variant: "caption" }, "Skipped") : /* @__PURE__ */ React.createElement(StepTimeTicker, { step }))
        )));
      })
    ));
  }
);
const hasLinks = ({ links = [] }) => links.length > 0;
const TaskPage = (props) => {
  const { loadingText } = props;
  const classes = useStyles();
  const navigate = useNavigate();
  const rootPath = useRouteRef(rootRouteRef);
  const scaffolderApi = useApi(scaffolderApiRef);
  const templateRoute = useRouteRef(selectedTemplateRouteRef);
  const [userSelectedStepId, setUserSelectedStepId] = useState(void 0);
  const [clickedToCancel, setClickedToCancel] = useState(false);
  const [lastActiveStepId, setLastActiveStepId] = useState(
    void 0
  );
  const { taskId } = useRouteRefParams(scaffolderTaskRouteRef);
  const taskStream = useTaskEventStream(taskId);
  const completed = taskStream.completed;
  const taskCancelled = taskStream.cancelled;
  const steps = useMemo(
    () => {
      var _a, _b;
      return (_b = (_a = taskStream.task) == null ? void 0 : _a.spec.steps.map((step) => {
        var _a2;
        return {
          ...step,
          ...(_a2 = taskStream == null ? void 0 : taskStream.steps) == null ? void 0 : _a2[step.id]
        };
      })) != null ? _b : [];
    },
    [taskStream]
  );
  useEffect(() => {
    var _a;
    const mostRecentFailedOrActiveStep = steps.find(
      (step) => ["failed", "processing"].includes(step.status)
    );
    if (completed && !mostRecentFailedOrActiveStep) {
      setLastActiveStepId((_a = steps[steps.length - 1]) == null ? void 0 : _a.id);
      return;
    }
    setLastActiveStepId(mostRecentFailedOrActiveStep == null ? void 0 : mostRecentFailedOrActiveStep.id);
  }, [steps, completed]);
  const currentStepId = userSelectedStepId != null ? userSelectedStepId : lastActiveStepId;
  const logAsString = useMemo(() => {
    if (!currentStepId) {
      return loadingText ? loadingText : "Loading...";
    }
    const log = taskStream.stepLogs[currentStepId];
    if (!(log == null ? void 0 : log.length)) {
      return "Waiting for logs...";
    }
    return log.join("\n");
  }, [taskStream.stepLogs, currentStepId, loadingText]);
  const taskNotFound = taskStream.completed && !taskStream.loading && !taskStream.task;
  const { output } = taskStream;
  const handleStartOver = () => {
    var _a, _b, _c;
    if (!taskStream.task || !((_b = (_a = taskStream.task) == null ? void 0 : _a.spec.templateInfo) == null ? void 0 : _b.entityRef)) {
      navigate(rootPath());
      return;
    }
    const formData = taskStream.task.spec.parameters;
    const { name, namespace } = parseEntityRef(
      (_c = taskStream.task.spec.templateInfo) == null ? void 0 : _c.entityRef
    );
    navigate(
      `${templateRoute({ templateName: name, namespace })}?${qs.stringify({
        formData: JSON.stringify(formData)
      })}`
    );
  };
  const handleCancel = async () => {
    setClickedToCancel(true);
    await scaffolderApi.cancelTask(taskId);
  };
  return /* @__PURE__ */ React.createElement(Page, { themeId: "home" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: `Task ${taskId}`,
      title: "Task Activity",
      subtitle: `Activity for task: ${taskId}`
    }
  ), /* @__PURE__ */ React.createElement(Content, null, taskNotFound ? /* @__PURE__ */ React.createElement(
    ErrorPage,
    {
      status: "404",
      statusMessage: "Task not found",
      additionalInfo: "No task found with this ID"
    }
  ) : /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(Grid$1, { container: true }, /* @__PURE__ */ React.createElement(Grid$1, { item: true, xs: 3 }, /* @__PURE__ */ React.createElement(Paper, null, /* @__PURE__ */ React.createElement(
    TaskStatusStepper,
    {
      steps,
      currentStepId,
      onUserStepChange: setUserSelectedStepId
    }
  ), output && hasLinks(output) && /* @__PURE__ */ React.createElement(TaskPageLinks, { output }), /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.button,
      onClick: handleStartOver,
      disabled: !completed,
      variant: "contained",
      color: "primary"
    },
    "Start Over"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.button,
      onClick: handleCancel,
      disabled: completed || taskCancelled || clickedToCancel,
      variant: "outlined",
      color: "secondary"
    },
    (taskCancelled || clickedToCancel) && !completed ? "Cancelling..." : "Cancel"
  ))), /* @__PURE__ */ React.createElement(Grid$1, { item: true, xs: 9 }, !currentStepId && /* @__PURE__ */ React.createElement(Progress, null), /* @__PURE__ */ React.createElement("div", { style: { height: "80vh" } }, /* @__PURE__ */ React.createElement(TaskErrors, { error: taskStream.error }), /* @__PURE__ */ React.createElement(LogViewer, { text: logAsString })))))));
};

export { entityNamePickerValidation as A, EntityNamePickerSchema as B, EntityTagsPicker as C, EntityTagsPickerSchema as D, EntityPickerFieldExtension as E, RepoUrlPicker as F, RepoUrlPickerSchema as G, OwnerPicker as H, OwnerPickerSchema as I, OwnedEntityPicker as J, OwnedEntityPickerSchema as K, NextScaffolderPage as N, OwnerPickerFieldExtension as O, RepoUrlPickerFieldExtension as R, ScaffolderClient as S, TaskPage as T, EntityNamePickerFieldExtension as a, EntityTagsPickerFieldExtension as b, OwnedEntityPickerFieldExtension as c, ScaffolderPage as d, EntityPickerFieldSchema as e, OwnerPickerFieldSchema as f, RepoUrlPickerFieldSchema as g, repoPickerValidation as h, OwnedEntityPickerFieldSchema as i, EntityTagsPickerFieldSchema as j, selectedTemplateRouteRef as k, TaskStatusStepper as l, makeFieldSchemaFromZod as m, TaskPageLinks as n, editRouteRef as o, actionsRouteRef as p, scaffolderListTaskRouteRef as q, rootRouteRef as r, scaffolderPlugin as s, registerComponentRouteRef as t, scaffolderTaskRouteRef as u, viewTechDocRouteRef as v, legacySelectedTemplateRouteRef as w, EntityPicker as x, EntityPickerSchema as y, EntityNamePicker as z };
//# sourceMappingURL=TaskPage-3afec1cb.esm.js.map
