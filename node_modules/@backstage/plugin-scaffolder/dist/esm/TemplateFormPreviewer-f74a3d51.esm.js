import React, { useState, useMemo, useEffect, useCallback, Component } from 'react';
import { Page, Header, Content, ErrorPanel } from '@backstage/core-components';
import { useParams, useNavigate } from 'react-router-dom';
import { makeStyles, useTheme, IconButton, Popover, MenuList, MenuItem, ListItemIcon, ListItemText, Box, Paper, Button, FormControl, InputLabel, Select, Card, CardHeader, CardContent, LinearProgress } from '@material-ui/core';
import { scaffolderApiRef, useTaskEventStream } from '@backstage/plugin-scaffolder-react';
import { k as selectedTemplateRouteRef } from './TaskPage-3afec1cb.esm.js';
import { useApi, useRouteRef, useApiHolder, alertApiRef } from '@backstage/core-plugin-api';
import qs from 'qs';
import { useAsync } from '@react-hookz/web';
import Cancel from '@material-ui/icons/Cancel';
import Retry from '@material-ui/icons/Repeat';
import Toc from '@material-ui/icons/Toc';
import ControlPointIcon from '@material-ui/icons/ControlPoint';
import MoreVert from '@material-ui/icons/MoreVert';
import { DefaultTemplateOutputs, TaskSteps, TaskLogStream, Stepper, Form } from '@backstage/plugin-scaffolder-react/alpha';
import { StreamLanguage } from '@codemirror/language';
import { yaml as yaml$1 } from '@codemirror/legacy-modes/mode/yaml';
import CloseIcon from '@material-ui/icons/Close';
import CodeMirror from '@uiw/react-codemirror';
import yaml from 'yaml';
import validator from '@rjsf/validator-ajv8';
import { u as useDryRun, a as useDirectoryEditor, D as DirectoryEditorProvider, b as DryRunProvider, T as TemplateEditorBrowser, c as TemplateEditorTextArea, d as DryRunResults } from './TemplateEditorIntro-48f2a0ae.esm.js';
import { catalogApiRef, humanizeEntityRef } from '@backstage/plugin-catalog-react';
import useAsync$1 from 'react-use/lib/useAsync';
import { makeStyles as makeStyles$1 } from '@material-ui/core/styles';
import useDebounce from 'react-use/lib/useDebounce';

const useStyles$5 = makeStyles(() => ({
  button: {
    color: ({ fontColor }) => fontColor
  }
}));
const ContextMenu = (props) => {
  const {
    cancelEnabled,
    logsVisible,
    buttonBarVisible,
    onStartOver,
    onToggleLogs,
    onToggleButtonBar,
    taskId
  } = props;
  const { getPageTheme } = useTheme();
  const pageTheme = getPageTheme({ themeId: "website" });
  const classes = useStyles$5({ fontColor: pageTheme.fontColor });
  const scaffolderApi = useApi(scaffolderApiRef);
  const [anchorEl, setAnchorEl] = useState();
  const [{ status: cancelStatus }, { execute: cancel }] = useAsync(async () => {
    if (taskId) {
      await scaffolderApi.cancelTask(taskId);
    }
  });
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    IconButton,
    {
      "aria-label": "more",
      "aria-controls": "long-menu",
      "aria-haspopup": "true",
      onClick: (event) => {
        setAnchorEl(event.currentTarget);
      },
      "data-testid": "menu-button",
      className: classes.button
    },
    /* @__PURE__ */ React.createElement(MoreVert, null)
  ), /* @__PURE__ */ React.createElement(
    Popover,
    {
      open: Boolean(anchorEl),
      onClose: () => setAnchorEl(void 0),
      anchorEl,
      anchorOrigin: { vertical: "bottom", horizontal: "right" },
      transformOrigin: { vertical: "top", horizontal: "right" }
    },
    /* @__PURE__ */ React.createElement(MenuList, null, /* @__PURE__ */ React.createElement(MenuItem, { onClick: () => onToggleLogs == null ? void 0 : onToggleLogs(!logsVisible) }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Toc, { fontSize: "small" })), /* @__PURE__ */ React.createElement(ListItemText, { primary: logsVisible ? "Hide Logs" : "Show Logs" })), /* @__PURE__ */ React.createElement(MenuItem, { onClick: () => onToggleButtonBar == null ? void 0 : onToggleButtonBar(!buttonBarVisible) }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(ControlPointIcon, { fontSize: "small" })), /* @__PURE__ */ React.createElement(
      ListItemText,
      {
        primary: buttonBarVisible ? "Hide Button Bar" : "Show Button Bar"
      }
    )), /* @__PURE__ */ React.createElement(MenuItem, { onClick: onStartOver }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Retry, { fontSize: "small" })), /* @__PURE__ */ React.createElement(ListItemText, { primary: "Start Over" })), /* @__PURE__ */ React.createElement(
      MenuItem,
      {
        onClick: cancel,
        disabled: !cancelEnabled || cancelStatus !== "not-executed",
        "data-testid": "cancel-task"
      },
      /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Cancel, { fontSize: "small" })),
      /* @__PURE__ */ React.createElement(ListItemText, { primary: "Cancel" })
    ))
  ));
};

const useStyles$4 = makeStyles((theme) => ({
  contentWrapper: {
    display: "flex",
    flexDirection: "column"
  },
  buttonBar: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "right"
  },
  cancelButton: {
    marginRight: theme.spacing(1)
  }
}));
const OngoingTask = (props) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { taskId } = useParams();
  const templateRouteRef = useRouteRef(selectedTemplateRouteRef);
  const navigate = useNavigate();
  const scaffolderApi = useApi(scaffolderApiRef);
  const taskStream = useTaskEventStream(taskId);
  const classes = useStyles$4();
  const steps = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = taskStream.task) == null ? void 0 : _a2.spec.steps.map((step) => {
        var _a3;
        return {
          ...step,
          ...(_a3 = taskStream == null ? void 0 : taskStream.steps) == null ? void 0 : _a3[step.id]
        };
      })) != null ? _b2 : [];
    },
    [taskStream]
  );
  const [logsVisible, setLogVisibleState] = useState(false);
  const [buttonBarVisible, setButtonBarVisibleState] = useState(true);
  useEffect(() => {
    if (taskStream.error) {
      setLogVisibleState(true);
    }
  }, [taskStream.error]);
  useEffect(() => {
    if (taskStream.completed && !taskStream.error) {
      setButtonBarVisibleState(false);
    }
  }, [taskStream.error, taskStream.completed]);
  const activeStep = useMemo(() => {
    for (let i = steps.length - 1; i >= 0; i--) {
      if (steps[i].status !== "open") {
        return i;
      }
    }
    return 0;
  }, [steps]);
  const startOver = useCallback(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const { namespace, name } = (_d2 = (_c2 = (_b2 = (_a2 = taskStream.task) == null ? void 0 : _a2.spec.templateInfo) == null ? void 0 : _b2.entity) == null ? void 0 : _c2.metadata) != null ? _d2 : {};
    const formData = (_f2 = (_e2 = taskStream.task) == null ? void 0 : _e2.spec.parameters) != null ? _f2 : {};
    if (!namespace || !name) {
      return;
    }
    navigate({
      pathname: templateRouteRef({
        namespace,
        templateName: name
      }),
      search: `?${qs.stringify({ formData: JSON.stringify(formData) })}`
    });
  }, [
    navigate,
    (_a = taskStream.task) == null ? void 0 : _a.spec.parameters,
    (_d = (_c = (_b = taskStream.task) == null ? void 0 : _b.spec.templateInfo) == null ? void 0 : _c.entity) == null ? void 0 : _d.metadata,
    templateRouteRef
  ]);
  const [{ status: cancelStatus }, { execute: triggerCancel }] = useAsync(
    async () => {
      if (taskId) {
        await scaffolderApi.cancelTask(taskId);
      }
    }
  );
  const Outputs = (_e = props.TemplateOutputsComponent) != null ? _e : DefaultTemplateOutputs;
  const templateName = (_h = (_g = (_f = taskStream.task) == null ? void 0 : _f.spec.templateInfo) == null ? void 0 : _g.entity) == null ? void 0 : _h.metadata.name;
  const cancelEnabled = !(taskStream.cancelled || taskStream.completed);
  return /* @__PURE__ */ React.createElement(Page, { themeId: "website" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: `Run of ${templateName}`,
      title: /* @__PURE__ */ React.createElement("div", null, "Run of ", /* @__PURE__ */ React.createElement("code", null, templateName)),
      subtitle: `Task ${taskId}`
    },
    /* @__PURE__ */ React.createElement(
      ContextMenu,
      {
        cancelEnabled,
        logsVisible,
        buttonBarVisible,
        onStartOver: startOver,
        onToggleLogs: setLogVisibleState,
        onToggleButtonBar: setButtonBarVisibleState,
        taskId
      }
    )
  ), /* @__PURE__ */ React.createElement(Content, { className: classes.contentWrapper }, taskStream.error ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(
    ErrorPanel,
    {
      error: taskStream.error,
      title: taskStream.error.message
    }
  )) : null, /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(
    TaskSteps,
    {
      steps,
      activeStep,
      isComplete: taskStream.completed,
      isError: Boolean(taskStream.error)
    }
  )), /* @__PURE__ */ React.createElement(Outputs, { output: taskStream.output }), buttonBarVisible ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(Paper, null, /* @__PURE__ */ React.createElement(Box, { padding: 2 }, /* @__PURE__ */ React.createElement("div", { className: classes.buttonBar }, /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.cancelButton,
      disabled: !cancelEnabled || cancelStatus !== "not-executed",
      onClick: triggerCancel,
      "data-testid": "cancel-button"
    },
    "Cancel"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "primary",
      disabled: cancelEnabled,
      onClick: startOver
    },
    "Start Over"
  ))))) : null, logsVisible ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2, height: "100%" }, /* @__PURE__ */ React.createElement(Paper, { style: { height: "100%" } }, /* @__PURE__ */ React.createElement(Box, { padding: 2, height: "100%" }, /* @__PURE__ */ React.createElement(TaskLogStream, { logs: taskStream.stepLogs })))) : null));
};

const useStyles$3 = makeStyles$1({
  containerWrapper: {
    position: "relative",
    width: "100%",
    height: "100%"
  },
  container: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    overflow: "auto"
  }
});
class ErrorBoundary extends Component {
  constructor() {
    super(...arguments);
    this.state = {
      shouldRender: true
    };
  }
  componentDidUpdate(prevProps) {
    if (prevProps.invalidator !== this.props.invalidator) {
      this.setState({ shouldRender: true });
    }
  }
  componentDidCatch(error) {
    this.props.setErrorText(error.message);
    this.setState({ shouldRender: false });
  }
  render() {
    return this.state.shouldRender ? this.props.children : null;
  }
}
function isJsonObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function TemplateEditorForm(props) {
  const {
    content,
    contentIsSpec,
    onDryRun,
    setErrorText,
    fieldExtensions = [],
    layouts = []
  } = props;
  const classes = useStyles$3();
  const apiHolder = useApiHolder();
  const [steps, setSteps] = useState();
  useDebounce(
    () => {
      try {
        if (!content) {
          setSteps(void 0);
          return;
        }
        const parsed = yaml.parse(content);
        if (!isJsonObject(parsed)) {
          setSteps(void 0);
          return;
        }
        let rootObj = parsed;
        if (!contentIsSpec) {
          const isTemplate = String(parsed.kind).toLocaleLowerCase("en-US") === "template";
          if (!isTemplate) {
            setSteps(void 0);
            return;
          }
          rootObj = isJsonObject(parsed.spec) ? parsed.spec : {};
        }
        const { parameters } = rootObj;
        if (!Array.isArray(parameters)) {
          setErrorText("Template parameters must be an array");
          setSteps(void 0);
          return;
        }
        setErrorText();
        setSteps(
          parameters.flatMap(
            (param) => isJsonObject(param) ? [
              {
                title: String(param.title),
                schema: param
              }
            ] : []
          )
        );
      } catch (e) {
        setErrorText(e.message);
      }
    },
    250,
    [contentIsSpec, content, apiHolder]
  );
  if (!steps) {
    return null;
  }
  return /* @__PURE__ */ React.createElement("div", { className: classes.containerWrapper }, /* @__PURE__ */ React.createElement("div", { className: classes.container }, /* @__PURE__ */ React.createElement(ErrorBoundary, { invalidator: steps, setErrorText }, /* @__PURE__ */ React.createElement(
    Stepper,
    {
      manifest: { steps, title: "Template Editor" },
      extensions: fieldExtensions,
      onCreate: async (data) => {
        await (onDryRun == null ? void 0 : onDryRun(data));
      },
      layouts,
      components: { createButtonText: onDryRun && "Try It" }
    }
  ))));
}
function TemplateEditorFormDirectoryEditorDryRun(props) {
  const { setErrorText, fieldExtensions = [], layouts } = props;
  const dryRun = useDryRun();
  const directoryEditor = useDirectoryEditor();
  const { selectedFile } = directoryEditor;
  const handleDryRun = async (values) => {
    if (!selectedFile) {
      return;
    }
    try {
      await dryRun.execute({
        templateContent: selectedFile.content,
        values,
        files: directoryEditor.files
      });
      setErrorText();
    } catch (e) {
      setErrorText(String(e.cause || e));
      throw e;
    }
  };
  const content = selectedFile && selectedFile.path.match(/\.ya?ml$/) ? selectedFile.content : void 0;
  return /* @__PURE__ */ React.createElement(
    TemplateEditorForm,
    {
      onDryRun: handleDryRun,
      fieldExtensions,
      setErrorText,
      content,
      layouts
    }
  );
}
TemplateEditorForm.DirectoryEditorDryRun = TemplateEditorFormDirectoryEditorDryRun;

const useStyles$2 = makeStyles((theme) => ({
  root: {
    gridArea: "pageContent",
    display: "grid",
    gridTemplateAreas: `
      "controls controls"
      "fieldForm preview"
    `,
    gridTemplateRows: "auto 1fr",
    gridTemplateColumns: "1fr 1fr"
  },
  controls: {
    gridArea: "controls",
    display: "flex",
    flexFlow: "row nowrap",
    alignItems: "center",
    margin: theme.spacing(1)
  },
  fieldForm: {
    gridArea: "fieldForm"
  },
  preview: {
    gridArea: "preview"
  }
}));
const CustomFieldExplorer = ({
  customFieldExtensions = [],
  onClose
}) => {
  var _a, _b;
  const classes = useStyles$2();
  const fieldOptions = customFieldExtensions.filter((field) => !!field.schema);
  const [selectedField, setSelectedField] = useState(fieldOptions[0]);
  const [fieldFormState, setFieldFormState] = useState({});
  const [refreshKey, setRefreshKey] = useState(Date.now());
  const sampleFieldTemplate = useMemo(
    () => {
      var _a2, _b2;
      return yaml.stringify({
        parameters: [
          {
            title: `${selectedField.name} Example`,
            properties: {
              [selectedField.name]: {
                type: (_b2 = (_a2 = selectedField.schema) == null ? void 0 : _a2.returnValue) == null ? void 0 : _b2.type,
                "ui:field": selectedField.name,
                "ui:options": fieldFormState
              }
            }
          }
        ]
      });
    },
    [fieldFormState, selectedField]
  );
  const fieldComponents = useMemo(() => {
    return Object.fromEntries(
      customFieldExtensions.map(({ name, component }) => [name, component])
    );
  }, [customFieldExtensions]);
  const handleSelectionChange = useCallback(
    (selection) => {
      setSelectedField(selection);
      setFieldFormState({});
    },
    [setFieldFormState, setSelectedField]
  );
  const handleFieldConfigChange = useCallback(
    (state) => {
      setFieldFormState(state);
      setRefreshKey(Date.now());
    },
    [setFieldFormState, setRefreshKey]
  );
  return /* @__PURE__ */ React.createElement("main", { className: classes.root }, /* @__PURE__ */ React.createElement("div", { className: classes.controls }, /* @__PURE__ */ React.createElement(FormControl, { variant: "outlined", size: "small", fullWidth: true }, /* @__PURE__ */ React.createElement(InputLabel, { id: "select-field-label" }, "Choose Custom Field Extension"), /* @__PURE__ */ React.createElement(
    Select,
    {
      value: selectedField,
      label: "Choose Custom Field Extension",
      labelId: "select-field-label",
      onChange: (e) => handleSelectionChange(e.target.value)
    },
    fieldOptions.map((option, idx) => /* @__PURE__ */ React.createElement(MenuItem, { key: idx, value: option }, option.name))
  )), /* @__PURE__ */ React.createElement(IconButton, { size: "medium", onClick: onClose, "aria-label": "Close" }, /* @__PURE__ */ React.createElement(CloseIcon, null))), /* @__PURE__ */ React.createElement("div", { className: classes.fieldForm }, /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardHeader, { title: "Field Options" }), /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(
    Form,
    {
      showErrorList: false,
      fields: { ...fieldComponents },
      noHtml5Validate: true,
      formData: fieldFormState,
      formContext: { fieldFormState },
      onSubmit: (e) => handleFieldConfigChange(e.formData),
      validator,
      schema: ((_a = selectedField.schema) == null ? void 0 : _a.uiOptions) || {}
    },
    /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "primary",
        type: "submit",
        disabled: !((_b = selectedField.schema) == null ? void 0 : _b.uiOptions)
      },
      "Apply"
    )
  )))), /* @__PURE__ */ React.createElement("div", { className: classes.preview }, /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardHeader, { title: "Example Template Spec" }), /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(
    CodeMirror,
    {
      readOnly: true,
      theme: "dark",
      height: "100%",
      extensions: [StreamLanguage.define(yaml$1)],
      value: sampleFieldTemplate
    }
  ))), /* @__PURE__ */ React.createElement(
    TemplateEditorForm,
    {
      key: refreshKey,
      content: sampleFieldTemplate,
      contentIsSpec: true,
      fieldExtensions: customFieldExtensions,
      setErrorText: () => null
    }
  )));
};

const useStyles$1 = makeStyles({
  // Reset and fix sizing to make sure scrolling behaves correctly
  root: {
    gridArea: "pageContent",
    display: "grid",
    gridTemplateAreas: `
      "browser editor preview"
      "results results results"
    `,
    gridTemplateColumns: "1fr 3fr 2fr",
    gridTemplateRows: "1fr auto"
  },
  browser: {
    gridArea: "browser",
    overflow: "auto"
  },
  editor: {
    gridArea: "editor",
    overflow: "auto"
  },
  preview: {
    gridArea: "preview",
    overflow: "auto"
  },
  results: {
    gridArea: "results"
  }
});
const TemplateEditor = (props) => {
  const classes = useStyles$1();
  const [errorText, setErrorText] = useState();
  return /* @__PURE__ */ React.createElement(DirectoryEditorProvider, { directory: props.directory }, /* @__PURE__ */ React.createElement(DryRunProvider, null, /* @__PURE__ */ React.createElement("main", { className: classes.root }, /* @__PURE__ */ React.createElement("section", { className: classes.browser }, /* @__PURE__ */ React.createElement(TemplateEditorBrowser, { onClose: props.onClose })), /* @__PURE__ */ React.createElement("section", { className: classes.editor }, /* @__PURE__ */ React.createElement(TemplateEditorTextArea.DirectoryEditor, { errorText })), /* @__PURE__ */ React.createElement("section", { className: classes.preview }, /* @__PURE__ */ React.createElement(
    TemplateEditorForm.DirectoryEditorDryRun,
    {
      setErrorText,
      fieldExtensions: props.fieldExtensions,
      layouts: props.layouts
    }
  )), /* @__PURE__ */ React.createElement("section", { className: classes.results }, /* @__PURE__ */ React.createElement(DryRunResults, null)))));
};

const EXAMPLE_TEMPLATE_PARAMS_YAML = `# Edit the template parameters below to see how they will render in the scaffolder form UI
parameters:
  - title: Fill in some steps
    required:
      - name
    properties:
      name:
        title: Name
        type: string
        description: Unique name of the component
      owner:
        title: Owner
        type: string
        description: Owner of the component
        ui:field: OwnerPicker
        ui:options:
          catalogFilter:
            kind: Group
  - title: Choose a location
    required:
      - repoUrl
    properties:
      repoUrl:
        title: Repository Location
        type: string
        ui:field: RepoUrlPicker
        ui:options:
          allowedHosts:
            - github.com
steps:
  - id: fetch-base
    name: Fetch Base
    action: fetch:template
    input:
      url: ./template
      values:
        name: \${{parameters.name}}
`;
const useStyles = makeStyles((theme) => ({
  root: {
    gridArea: "pageContent",
    display: "grid",
    gridTemplateAreas: `
      "controls controls"
      "textArea preview"
    `,
    gridTemplateRows: "auto 1fr",
    gridTemplateColumns: "1fr 1fr"
  },
  controls: {
    gridArea: "controls",
    display: "flex",
    flexFlow: "row nowrap",
    alignItems: "center",
    margin: theme.spacing(1)
  },
  textArea: {
    gridArea: "textArea"
  },
  preview: {
    gridArea: "preview"
  }
}));
const TemplateFormPreviewer = ({
  defaultPreviewTemplate = EXAMPLE_TEMPLATE_PARAMS_YAML,
  customFieldExtensions = [],
  onClose,
  layouts = []
}) => {
  const classes = useStyles();
  const alertApi = useApi(alertApiRef);
  const catalogApi = useApi(catalogApiRef);
  const [selectedTemplate, setSelectedTemplate] = useState("");
  const [errorText, setErrorText] = useState();
  const [templateOptions, setTemplateOptions] = useState([]);
  const [templateYaml, setTemplateYaml] = useState(defaultPreviewTemplate);
  const { loading } = useAsync$1(
    () => catalogApi.getEntities({
      filter: { kind: "template" },
      fields: [
        "kind",
        "metadata.namespace",
        "metadata.name",
        "metadata.title",
        "spec.parameters",
        "spec.steps",
        "spec.output"
      ]
    }).then(
      ({ items }) => setTemplateOptions(
        items.map((template) => {
          var _a;
          return {
            label: (_a = template.metadata.title) != null ? _a : humanizeEntityRef(template, { defaultKind: "template" }),
            value: template
          };
        })
      )
    ).catch(
      (e) => alertApi.post({
        message: `Error loading exisiting templates: ${e.message}`,
        severity: "error"
      })
    ),
    [catalogApi]
  );
  const handleSelectChange = useCallback(
    (selected) => {
      setSelectedTemplate(selected);
      setTemplateYaml(yaml.stringify(selected.spec));
    },
    [setTemplateYaml]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, loading && /* @__PURE__ */ React.createElement(LinearProgress, null), /* @__PURE__ */ React.createElement("main", { className: classes.root }, /* @__PURE__ */ React.createElement("div", { className: classes.controls }, /* @__PURE__ */ React.createElement(FormControl, { variant: "outlined", size: "small", fullWidth: true }, /* @__PURE__ */ React.createElement(InputLabel, { id: "select-template-label" }, "Load Existing Template"), /* @__PURE__ */ React.createElement(
    Select,
    {
      value: selectedTemplate,
      label: "Load Existing Template",
      labelId: "select-template-label",
      onChange: (e) => handleSelectChange(e.target.value)
    },
    templateOptions.map((option, idx) => /* @__PURE__ */ React.createElement(MenuItem, { key: idx, value: option.value }, option.label))
  )), /* @__PURE__ */ React.createElement(IconButton, { size: "medium", onClick: onClose }, /* @__PURE__ */ React.createElement(CloseIcon, null))), /* @__PURE__ */ React.createElement("div", { className: classes.textArea }, /* @__PURE__ */ React.createElement(
    TemplateEditorTextArea,
    {
      content: templateYaml,
      onUpdate: setTemplateYaml,
      errorText
    }
  )), /* @__PURE__ */ React.createElement("div", { className: classes.preview }, /* @__PURE__ */ React.createElement(
    TemplateEditorForm,
    {
      content: templateYaml,
      contentIsSpec: true,
      fieldExtensions: customFieldExtensions,
      setErrorText,
      layouts
    }
  ))));
};

export { CustomFieldExplorer as C, OngoingTask as O, TemplateEditor as T, TemplateFormPreviewer as a };
//# sourceMappingURL=TemplateFormPreviewer-f74a3d51.esm.js.map
