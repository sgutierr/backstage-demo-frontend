'use strict';

var fs = require('fs-extra');
var npmPackList = require('npm-packlist');
var path = require('path');
var entryPoints = require('./entryPoints-0cc55995.cjs.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var npmPackList__default = /*#__PURE__*/_interopDefaultLegacy(npmPackList);

const PKG_PATH = "package.json";
const PKG_BACKUP_PATH = "package.json-prepack";
const SKIPPED_KEYS = ["access", "registry", "tag", "alphaTypes", "betaTypes"];
const SCRIPT_EXTS = [".js", ".jsx", ".ts", ".tsx"];
async function productionPack(options) {
  var _a, _b, _c;
  const { packageDir, targetDir } = options;
  const pkgPath = path.resolve(packageDir, PKG_PATH);
  const pkgContent = await fs__default["default"].readFile(pkgPath, "utf8");
  const pkg = JSON.parse(pkgContent);
  if (!targetDir) {
    await fs__default["default"].writeFile(PKG_BACKUP_PATH, pkgContent);
  }
  const hasStageEntry = !!((_a = pkg.publishConfig) == null ? void 0 : _a.alphaTypes) || !!((_b = pkg.publishConfig) == null ? void 0 : _b.betaTypes);
  if (pkg.exports && hasStageEntry) {
    throw new Error(
      "Combining both exports and alpha/beta types is not supported"
    );
  }
  const writeCompatibilityEntryPoints = await prepareExportsEntryPoints(
    pkg,
    packageDir
  );
  const publishConfig = (_c = pkg.publishConfig) != null ? _c : {};
  for (const key of Object.keys(publishConfig)) {
    if (!SKIPPED_KEYS.includes(key)) {
      pkg[key] = publishConfig[key];
    }
  }
  delete pkg.typesVersions;
  if (pkg.bundled) {
    delete pkg.dependencies;
    delete pkg.devDependencies;
    delete pkg.peerDependencies;
    delete pkg.optionalDependencies;
  }
  if (targetDir) {
    const filePaths = await npmPackList__default["default"]({
      path: packageDir,
      // This makes sure we use the updated package.json when listing files
      packageJsonCache: /* @__PURE__ */ new Map([
        [path.resolve(packageDir, PKG_PATH), pkg]
      ])
      // Seems like this parameter type is wrong,
    });
    await fs__default["default"].ensureDir(targetDir);
    for (const filePath of filePaths.sort()) {
      const target = path.resolve(targetDir, filePath);
      if (filePath === PKG_PATH) {
        await fs__default["default"].writeJson(target, pkg, { encoding: "utf8", spaces: 2 });
      } else {
        await fs__default["default"].copy(path.resolve(packageDir, filePath), target);
      }
    }
  } else {
    await fs__default["default"].writeJson(pkgPath, pkg, { encoding: "utf8", spaces: 2 });
  }
  if (publishConfig.alphaTypes) {
    await writeReleaseStageEntrypoint(pkg, "alpha", targetDir != null ? targetDir : packageDir);
  }
  if (publishConfig.betaTypes) {
    await writeReleaseStageEntrypoint(pkg, "beta", targetDir != null ? targetDir : packageDir);
  }
  if (writeCompatibilityEntryPoints) {
    await writeCompatibilityEntryPoints(targetDir != null ? targetDir : packageDir);
  }
}
async function revertProductionPack(packageDir) {
  var _a, _b;
  try {
    await fs__default["default"].move(PKG_BACKUP_PATH, PKG_PATH, { overwrite: true });
    const pkg = await fs__default["default"].readJson(PKG_PATH);
    if ((_a = pkg.publishConfig) == null ? void 0 : _a.alphaTypes) {
      await fs__default["default"].remove(path.resolve(packageDir, "alpha"));
    }
    if ((_b = pkg.publishConfig) == null ? void 0 : _b.betaTypes) {
      await fs__default["default"].remove(path.resolve(packageDir, "beta"));
    }
    const entryPoints$1 = entryPoints.readEntryPoints(pkg);
    for (const entryPoint of entryPoints$1) {
      if (entryPoint.mount !== "." && SCRIPT_EXTS.includes(entryPoint.ext)) {
        await fs__default["default"].remove(path.resolve(packageDir, entryPoint.name));
      }
    }
  } catch (error) {
    console.warn(
      `Failed to restore package.json, ${error}. Your package will be fine but you may have ended up with some garbage in the repo.`
    );
  }
}
function resolveEntrypoint(pkg, name) {
  const targetEntry = pkg.publishConfig[name] || pkg[name];
  return targetEntry && path.posix.join("..", targetEntry);
}
async function writeReleaseStageEntrypoint(pkg, stage, targetDir) {
  await fs__default["default"].ensureDir(path.resolve(targetDir, stage));
  await fs__default["default"].writeJson(
    path.resolve(targetDir, stage, PKG_PATH),
    {
      name: pkg.name,
      version: pkg.version,
      main: resolveEntrypoint(pkg, "main"),
      module: resolveEntrypoint(pkg, "module"),
      browser: resolveEntrypoint(pkg, "browser"),
      types: path.posix.join("..", pkg.publishConfig[`${stage}Types`])
    },
    { encoding: "utf8", spaces: 2 }
  );
}
const EXPORT_MAP = {
  import: ".esm.js",
  require: ".cjs.js",
  types: ".d.ts"
};
async function prepareExportsEntryPoints(pkg, packageDir) {
  var _a;
  const distPath = path.resolve(packageDir, "dist");
  if (!await fs__default["default"].pathExists(distPath)) {
    return void 0;
  }
  const distFiles = await fs__default["default"].readdir(distPath);
  const outputExports = {};
  const compatibilityWriters = new Array();
  const entryPoints$1 = entryPoints.readEntryPoints(pkg);
  for (const entryPoint of entryPoints$1) {
    if (!SCRIPT_EXTS.includes(entryPoint.ext)) {
      outputExports[entryPoint.mount] = entryPoint.path;
      continue;
    }
    const exp = {};
    for (const [key, ext] of Object.entries(EXPORT_MAP)) {
      const name = `${entryPoint.name}${ext}`;
      if (distFiles.includes(name)) {
        exp[key] = `./${path.posix.join(`dist`, name)}`;
      }
    }
    exp.default = (_a = exp.require) != null ? _a : exp.import;
    if (entryPoint.mount === ".") {
      if (exp.default) {
        pkg.main = exp.default;
      }
      if (exp.import) {
        pkg.module = exp.import;
      }
      if (exp.types) {
        pkg.types = exp.types;
      }
    } else {
      compatibilityWriters.push(async (targetDir) => {
        const entryPointDir = path.resolve(targetDir, entryPoint.name);
        await fs__default["default"].ensureDir(entryPointDir);
        await fs__default["default"].writeJson(
          path.resolve(entryPointDir, PKG_PATH),
          {
            name: pkg.name,
            version: pkg.version,
            ...exp.default ? { main: path.posix.join("..", exp.default) } : {},
            ...exp.import ? { module: path.posix.join("..", exp.import) } : {},
            ...exp.types ? { types: path.posix.join("..", exp.types) } : {}
          },
          { encoding: "utf8", spaces: 2 }
        );
      });
      if (Array.isArray(pkg.files) && !pkg.files.includes(entryPoint.name)) {
        pkg.files.push(entryPoint.name);
      }
    }
    if (Object.keys(exp).length > 0) {
      outputExports[entryPoint.mount] = exp;
    }
  }
  if (pkg.exports) {
    pkg.exports = outputExports;
    pkg.exports["./package.json"] = "./package.json";
  }
  if (compatibilityWriters.length > 0) {
    return async (targetDir) => {
      await Promise.all(compatibilityWriters.map((writer) => writer(targetDir)));
    };
  }
  return void 0;
}

exports.productionPack = productionPack;
exports.revertProductionPack = revertProductionPack;
//# sourceMappingURL=productionPack-d569941a.cjs.js.map
