'use strict';

var fs = require('fs-extra');
var path = require('path');
var cliNode = require('@backstage/cli-node');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

function trimRelative(path) {
  if (path.startsWith("./")) {
    return path.slice(2);
  }
  return path;
}
async function command() {
  const packages = await cliNode.PackageGraph.listTargetPackages();
  await Promise.all(
    packages.map(async ({ dir, packageJson }) => {
      let changed = false;
      let newPackageJson = packageJson;
      let { exports: exp } = newPackageJson;
      if (!exp) {
        return;
      }
      if (Array.isArray(exp)) {
        throw new Error("Unexpected array in package.json exports field");
      }
      if (typeof exp === "string") {
        changed = true;
        exp = { ".": exp };
        newPackageJson.exports = exp;
      } else if (typeof exp !== "object") {
        return;
      }
      if (!exp["./package.json"]) {
        changed = true;
        exp["./package.json"] = "./package.json";
      }
      const existingTypesVersions = JSON.stringify(packageJson.typesVersions);
      const typeEntries = {};
      for (const [path, value] of Object.entries(exp)) {
        if (path === ".") {
          continue;
        }
        const newPath = trimRelative(path);
        if (typeof value === "string") {
          typeEntries[newPath] = [trimRelative(value)];
        } else if (value && typeof value === "object" && !Array.isArray(value)) {
          if (typeof value.types === "string") {
            typeEntries[newPath] = [trimRelative(value.types)];
          } else if (typeof value.default === "string") {
            typeEntries[newPath] = [trimRelative(value.default)];
          }
        }
      }
      const typesVersions = { "*": typeEntries };
      if (existingTypesVersions !== JSON.stringify(typesVersions)) {
        console.log(`Synchronizing exports in ${packageJson.name}`);
        const newPkgEntries = Object.entries(newPackageJson).filter(
          ([name]) => name !== "typesVersions"
        );
        newPkgEntries.splice(
          newPkgEntries.findIndex(([name]) => name === "exports") + 1,
          0,
          ["typesVersions", typesVersions]
        );
        newPackageJson = Object.fromEntries(
          newPkgEntries
        );
        changed = true;
      }
      const publishConfig = newPackageJson.publishConfig;
      if (publishConfig) {
        for (const field of ["main", "module", "browser", "types"]) {
          if (publishConfig[field]) {
            delete publishConfig[field];
            changed = true;
          }
        }
      }
      if (changed) {
        await fs__default["default"].writeJson(path.resolve(dir, "package.json"), newPackageJson, {
          spaces: 2
        });
      }
    })
  );
}

exports.command = command;
//# sourceMappingURL=packageExports-50d8546d.cjs.js.map
